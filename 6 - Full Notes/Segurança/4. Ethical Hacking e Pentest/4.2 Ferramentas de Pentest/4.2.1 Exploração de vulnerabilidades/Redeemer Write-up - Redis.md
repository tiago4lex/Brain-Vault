2025-08-03 07:52

Status: #developed #segurança 

Tags: [[CyberSecurity]] | [[Redes]] | [[Nmap]]

----
# Introdução

Bancos de dados são um conjunto de informações organizadas que podem ser facilmente acessadas, gerenciadas e atualizadas. Na maioria dos ambientes, os sistemas de banco de dados são muito importantes porque comunicam informações relacionadas
às suas transações de vendas, estoque de produtos, perfis de clientes e atividades de marketing.

Existem diferentes tipos de bancos de dados e um deles é o Redis, que é um banco de dados *"in-memory"*. Bancos de dados *in-memory* são aqueles que <font color="#ffc000"><strong>dependem essencialmente da memória primária para armazenamento de dados</strong></font> (o que significa que
o banco de dados é gerenciado na RAM do sistema); em contraste com bancos de dados que armazenam dados em disco ou SSDs. Como a memória primária é significativamente mais rápida do que a secundária, o tempo de recuperação de dados no caso de bancos de dados "in-memory" é muito pequeno, oferecendo, assim, tempos de resposta muito eficientes e mínimos.

Bancos de dados em memória, como o **Redis**, são normalmente usados para armazenar em cache dados solicitados com frequência para recuperação rápida. Por exemplo, se houver um site que retorna alguns preços na página inicial, o site pode ser escrito para verificar primeiro se os preços necessários estão no Redis e, caso contrário, verificar o banco de dados tradicional (como MySQL ou MongoDB). Quando o valor é carregado do banco de dados, ele é armazenado no Redis por um período mais curto (segundos, minutos ou horas), para lidar com quaisquer solicitações semelhantes que cheguem durante esse período. Para um site com muito tráfego, essa configuração permite uma recuperação muito mais rápida para a maioria das solicitações, mantendo um armazenamento estável de longo prazo no banco de dados principal.

Este laboratório se concentra na enumeração remota de um servidor Redis e, em seguida, no dump do banco de dados para recuperar o sinalizador. Neste processo, aprendemos sobre o uso do utilitário de linha de comando redis-cli, que ajuda a interagir com o serviço Redis. Também aprendemos sobre alguns comandos básicos do `redis-cli`, usados para interagir com o servidor Redis e o banco de dados de chave-valor.

---
# Enumeração

Para verificar a conectividade e a disponibilidade do alvo, podemos executar o comando ping com o endereço IP da máquina alvo. Após duas respostas bem-sucedidas, podemos interromper o comando ping, pois estamos satisfeitos com a qualidade da conexão. Nem sempre precisamos executar comandos por muito tempo. Às vezes, obter um trecho do resultado ou uma visão geral em vez de um relatório detalhado é mais eficiente em termos de tempo do que a alternativa.

Imediatamente depois, podemos prosseguir com uma varredura preliminar do alvo. Usando o `nmap` com o switch de detecção de versão de serviço apropriado, varremos o endereço IP em busca de portas e serviços abertos.

```bash
nmap -p- -sV {ip_alvo}
```

![[Pasted image 20250803075847.png]]

Podemos inferir do resultado da verificação que apenas uma porta está aberta na máquina de destino, ou seja, a porta 6379, que está executando um servidor Redis.

---
# O que é Redis?

O **Redis** *(**RE**mote **DI**ctionary **S**erver)* é um repositório de dados NoSQL avançado de código aberto, baseado em chave-valor, usado como banco de dados, cache e agente de mensagens. Os dados são armazenados em um formato de dicionário com pares de chave-valor. É normalmente usado para armazenamento de curto prazo de dados que precisam de recuperação rápida. O Redis faz backup dos dados em discos rígidos para garantir consistência.

![[Pasted image 20250803080153.png]]

## O servidor

O Redis é executado como um software do lado do servidor, portanto, sua funcionalidade principal está em seu componente de servidor. O servidor escuta conexões de clientes, programaticamente ou por meio da interface de linha de comando.

## A CLI

A interface de linha de comando (CLI) é uma ferramenta poderosa que oferece acesso completo aos dados do Redis e suas
funcionalidades, caso você esteja desenvolvendo um software ou ferramenta que precise interagir com ele.

## Banco de Dados

O banco de dados é armazenado na RAM do servidor para permitir acesso rápido aos dados. O Redis também grava o conteúdo do banco de dados no disco em intervalos variáveis para mantê-lo como backup em caso de falha.

---
# Instalando o `redis-cli`

Agora, para poder interagir remotamente com o servidor Redis, precisamos baixar o utilitário redis-cli. Ele pode ser baixado usando o seguinte comando:

```bash
sudo apt install redis-tools
```

Como alternativa, também podemos nos conectar ao servidor Redis usando o utilitário `netcat`.

---
# Enumerando o Servidor Redis

Após instalar com sucesso o utilitário redis-cli, vamos visualizar sua página de ajuda digitando o comando `redis-cli --help` em nosso terminal para receber uma lista de todas as opções possíveis para a ferramenta e suas descrições.

```bash
redis-cli 7.0.15

Usage: redis-cli [OPTIONS] [cmd [arg [arg ...]]]
  -h <hostname>      Server hostname (default: 127.0.0.1).
  -p <port>          Server port (default: 6379).
  -s <socket>        Server socket (overrides hostname and port).
  -a <password>      Password to use when connecting to the server.
                     You can also use the REDISCLI_AUTH environment
                     variable to pass this password more safely
                     (if both are used, this argument takes precedence).
  --user <username>  Used to send ACL style 'AUTH username pass'. Needs -a.
  --pass <password>  Alias of -a for consistency with the new --user option.
  --askpass          Force user to input password with mask from STDIN.
                     If this argument is used, '-a' and REDISCLI_AUTH
                     environment variable will be ignored.
  -u <uri>           Server URI.
  -r <repeat>        Execute specified command N times.
  -i <interval>      When -r is used, waits <interval> seconds per command.
                     It is possible to specify sub-second times like -i 0.1.
                     This interval is also used in --scan and --stat per cycle.
                     and in --bigkeys, --memkeys, and --hotkeys per 100 cycles.
  -n <db>            Database number.
  -2                 Start session in RESP2 protocol mode.
  -3                 Start session in RESP3 protocol mode.
  -x                 Read last argument from STDIN (see example below).
  -X                 Read <tag> argument from STDIN (see example below).
  -d <delimiter>     Delimiter between response bulks for raw formatting (default: \n).
  -D <delimiter>     Delimiter between responses for raw formatting (default: \n).
  -c                 Enable cluster mode (follow -ASK and -MOVED redirections).
  -e                 Return exit error code when command execution fails.
  --tls              Establish a secure TLS connection.
  --sni <host>       Server name indication for TLS.
  --cacert <file>    CA Certificate file to verify with.
  --cacertdir <dir>  Directory where trusted CA certificates are stored.
                     If neither cacert nor cacertdir are specified, the default
                     system-wide trusted root certs configuration will apply.
  --insecure         Allow insecure TLS connection by skipping cert validation.
  --cert <file>      Client certificate to authenticate with.
  --key <file>       Private key file to authenticate with.
  --tls-ciphers <list> Sets the list of preferred ciphers (TLSv1.2 and below)
                     in order of preference from highest to lowest separated by colon (":").
                     See the ciphers(1ssl) manpage for more information about the syntax of this string.
  --tls-ciphersuites <list> Sets the list of preferred ciphersuites (TLSv1.3)
                     in order of preference from highest to lowest separated by colon (":").
                     See the ciphers(1ssl) manpage for more information about the syntax of this string,
                     and specifically for TLSv1.3 ciphersuites.
  --raw              Use raw formatting for replies (default when STDOUT is
                     not a tty).
  --no-raw           Force formatted output even when STDOUT is not a tty.
  --quoted-input     Force input to be handled as quoted strings.
  --csv              Output in CSV format.
  --json             Output in JSON format (default RESP3, use -2 if you want to use with RESP2).
  --quoted-json      Same as --json, but produce ASCII-safe quoted strings, not Unicode.
  --show-pushes <yn> Whether to print RESP3 PUSH messages.  Enabled by default when
                     STDOUT is a tty but can be overridden with --show-pushes no.
  --stat             Print rolling stats about server: mem, clients, ...
  --latency          Enter a special mode continuously sampling latency.
                     If you use this mode in an interactive session it runs
                     forever displaying real-time stats. Otherwise if --raw or
                     --csv is specified, or if you redirect the output to a non
                     TTY, it samples the latency for 1 second (you can use
                     -i to change the interval), then produces a single output
                     and exits.
  --latency-history  Like --latency but tracking latency changes over time.
                     Default time interval is 15 sec. Change it using -i.
  --latency-dist     Shows latency as a spectrum, requires xterm 256 colors.
                     Default time interval is 1 sec. Change it using -i.
  --lru-test <keys>  Simulate a cache workload with an 80-20 distribution.
  --replica          Simulate a replica showing commands received from the master.
  --rdb <filename>   Transfer an RDB dump from remote server to local file.
                     Use filename of "-" to write to stdout.
 --functions-rdb <filename> Like --rdb but only get the functions (not the keys)
                     when getting the RDB dump file.
  --pipe             Transfer raw Redis protocol from stdin to server.
  --pipe-timeout <n> In --pipe mode, abort with error if after sending all data.
                     no reply is received within <n> seconds.
                     Default timeout: 30. Use 0 to wait forever.
  --bigkeys          Sample Redis keys looking for keys with many elements (complexity).
  --memkeys          Sample Redis keys looking for keys consuming a lot of memory.
  --memkeys-samples <n> Sample Redis keys looking for keys consuming a lot of memory.
                     And define number of key elements to sample
  --hotkeys          Sample Redis keys looking for hot keys.
                     only works when maxmemory-policy is *lfu.
  --scan             List all keys using the SCAN command.
  --pattern <pat>    Keys pattern when using the --scan, --bigkeys or --hotkeys
                     options (default: *).
  --quoted-pattern <pat> Same as --pattern, but the specified string can be
                         quoted, in order to pass an otherwise non binary-safe string.
  --intrinsic-latency <sec> Run a test to measure intrinsic system latency.
                     The test will run for the specified amount of seconds.
  --eval <file>      Send an EVAL command using the Lua script at <file>.
  --ldb              Used with --eval enable the Redis Lua debugger.
  --ldb-sync-mode    Like --ldb but uses the synchronous Lua debugger, in
                     this mode the server is blocked and script changes are
                     not rolled back from the server memory.
  --cluster <command> [args...] [opts...]
                     Cluster Manager command and arguments (see below).
  --verbose          Verbose mode.
  --no-auth-warning  Dont show warning message when using password on command
                     line interface.
  --help             Output this help and exit.
  --version          Output version and exit.

Cluster Manager Commands:
  Use --cluster help to list all available cluster manager commands.

Examples:
  cat /etc/passwd | redis-cli -x set mypasswd
  redis-cli -D "" --raw dump key > key.dump && redis-cli -X dump_tag restore key2 0 dump_tag replace < key.dump
  redis-cli -r 100 lpush mylist x
  redis-cli -r 100 -i 1 info | grep used_memory_human:
  redis-cli --quoted-input set '"null-\x00-separated"' value
  redis-cli --eval myscript.lua key1 key2 , arg1 arg2 arg3
  redis-cli --scan --pattern '*:12345*'

  (Note: when using --eval the comma separates KEYS[] from ARGV[] items)

When no command is given, redis-cli starts in interactive mode.
Type "help" in interactive mode for information on available commands
and settings.
```

No nosso caso, precisaremos usar apenas a seguinte opção para especificar o host ao qual precisamos nos conectar:

```bash
-h <hostname> # especifique o nome do host do alvo ao qual se conectar
```

Vamos nos conectar ao servidor Redis usando o seguinte comando:

```bash
redis-cli -h {ip_alvo}
```

![[Pasted image 20250803081326.png]]

Após uma conexão bem-sucedida com o servidor Redis, devemos ver um prompt no terminal, como mostrado na imagem acima.
Um dos comandos básicos de enumeração do Redis é o `info`, que retorna informações e estatísticas sobre o servidor Redis. Como a saída deste comando é bastante longa, retirei as informações menos relevantes:

![[Pasted image 20250803081406.png]]

A seção `Keyspace` fornece estatísticas sobre o dicionário principal de cada banco de dados. As estatísticas incluem o número de chaves e o número de chaves com expiração.

No nosso caso, na seção `Keyspace`, podemos ver que existe apenas um banco de dados com índice `0`.

Vamos selecionar este banco de dados lógico Redis usando o comando select seguido do número de índice do banco de dados que precisa ser selecionado:

```bash
select 0
```

Além disso, podemos listar todas as chaves presentes no banco de dados usando o comando:

![[Pasted image 20250803081625.png]]

```bash
keys *
```

![[Pasted image 20250803081646.png]]

Por fim, podemos visualizar os valores armazenados para uma chave correspondente usando o comando `get` seguido da key:

```bash
get <key>
```

![[Pasted image 20250803081802.png]]

Parabéns! Recuperamos com sucesso o valor do sinalizador do banco de dados Redis.