2025-10-20 12:02

Status: #developed #Java 

Tags: [[Java]] | [[Programação Orientada a Objetos]] | [[Interface]] | [[Implements]]

----
# O que é uma Interface?

Em Java, **interface** é um **contrato que define um conjunto de métodos abstratos** (ou seja, sem corpo) que uma classe **deve obrigatoriamente implementar**.

Ela é uma forma de **garantir que diferentes classes** sigam o mesmo padrão de comportamento, sem precisar herdar código de uma classe concreta.

Em resumo:

- Uma **interface define oque deve ser feito**.
- Uma **classe define como será feito**.

---
# Estrutura de uma interface

```java
public interface Veiculo {
	void acelerar();
	void frear();
}
```

- `public interface`: palavra-chave para definir a interface.
- **Métodos sem corpo:** apenas o nome, tipo de retorno e parâmetros.
- **Por padrão**, todos os métodos de uma interface são:
	- `public`
	- `abstract`

---
# Implementando uma interface

Uma classe usa a palavra-chave `implements` para indicar que está **implementando** uma interface.

**Exemplo:**

```java
public class Carro implements Veiculo {
	@Override
	public void acelerar() {
		System.out.println("O carro está acelerando!");
	}
	
	@Override
	public void frear() {
		System.out.println("O carro está freando!");
	}
}
```

- O uso de `@Override` indica que os métodos estão sendo **implementados da interface**.
- A classe **deve implementar** todos os métodos da interface, ou será **abstrata**.

---
# Múltiplas Interfaces

Diferente da herança de classe (que é única em Java), uma classe pode **implementar várias interfaces**.

```java
public interaface Motor {
	void ligarMotor();
}

public interface  Luz {
	void acenderFarol();
}

public class Moto implements Veiculo, Motor, Luz {
	@Override
	public void acelerar() { System.out.println("A moto acelera!"); }
	
	@Override
	public void frear() { System.out.println("A moto freia!"); }
	
	@Override
	public void ligarMotor() { System.out.println("Motor ligado!"); }
	
	@Override
	public void acenderFarol() { System.out.println("Farol aceso!"); }
}
```

Isso é útil para **combinar comportamentos de diferentes origens**.

---
# Interface vs Classe Abstrata

|Característica|Interface|Classe Abstrata|
|---|---|---|
|Herança|Múltipla|Única|
|Métodos|Só assinatura (antes do Java 8)|Pode ter métodos abstratos e concretos|
|Variáveis|`public static final` por padrão|Pode ter variáveis normais|
|Uso principal|Contrato de comportamento|Base comum com lógica parcial|

**Exemplo de diferença:**

```java
// Interface
public interface Pagave {
	void pagar();
}

// Classe abastrata
public abstract class Conta {
	double saldo;
	abstract void calcularJuros();
}
```

---
# Interface com Métodos `default` e `static` (Java 8+)

A partir do Java 8, interfaces podem conter métodos com implementação, usando `default` e `static`.

### Exemplo com `default`:

```java
public interface Logavel {
	default void logar(String mensagem) {
		System.out.println("[LOG] " + mensagem);
	}
}
```

**Uso:**

```java
public class Servico implements Logavel {
	public void executar() {
		logar("Serviço executado com sucesso!");
	}
}
```

### Exemplo com `static`:

```java
public interface Util {
	static void mostrarVersao() {
		System.out.println("Versão 1.0");
	}
}
```

**Uso:**

```java
Util.mostrarVersao(); // chamado diretamente
```

---
# Interfaces como Tipos

Interfaces também podem ser usadas como **tipo de referência**:

```java
Veiculo meuVeiculo = new Carro();
meuVeiculo.acelerar();
```

Isso permite **polimorfismo**, onde diferentes classes que implementam a mesma interface podem ser usadas de forma intercambiável.

---
# Quando usar interfaces

Use interfaces quando:

- ✅ Você quer **definir um comportamento comum** para classes diferentes.  
- ✅ Precisa de **múltiplas heranças de comportamento**.  
- ✅ Deseja **desacoplar o código** — ou seja, permitir que diferentes implementações sejam trocadas facilmente.

**Exemplo prático:**

```java
public interface Repositorio {
	void salvar(String dado);
}

public class BancoDeDados implements Repositorio {
	@Override
	public void salvar(String dado) {
		System.out.println("Salvado no banco de dados: " + dado);
	}
}

public class Arquivo implements Repositorio {
	@Override
	public void salvar(String dado) {
		System.out.println("Salvando em arquivo: " + dado);
	}
}
```

**Uso:**

```java
Repositorio r = new BancoDeDados();
r.salvar("Usuário X");
```

O código pode mudar a implementação (`BancoDeDados` → `Arquivo`) **sem alterar o resto do sistema**.

---
# Exemplo completo

```java
public interface Animal {
	void emitirSom();
}

public class Cachorro implements Animal {
	@Override
	public void emitirSom() {
		System.out.println("Au au!");
	}
}

public class Gato implements Animal {
	@Override
	public void emitirSom() {
		System.out.println("Miau!");
	}
}

public class TesteInterface {
	public static void main(String[] args) {
		Animal a1 = new Cachorro();
		Animal a2 = new Gato();
		
		a1.emitirSom(); // "Au au!"
		a2.emitirSom(); // "Miau!"
	}
}
```

**Observe:**

- `Animal` é o contrato.
- `Cachorro` e `Gato` têm implementações diferentes.
- `TesteInterface` usa o mesmo tipo (`Animal`) para ambos - **polimorfismo em ação**.

---
# Conclusão

|Conceito|Explicação|
|---|---|
|**Interface**|Define um contrato de métodos|
|**Implementação**|Classe que define o comportamento dos métodos|
|**Polimorfismo**|Permite usar várias classes através de uma interface comum|
|**Default/Static**|Métodos com implementação dentro da interface|
|**Vantagem principal**|Reutilização, desacoplamento e flexibilidade no design de sistemas|