2025-10-12 10:41

Status: #developed #Java 

Tags: [[Java]] | [[Programação Orientada a Objetos]]

----
# O que são  *Getters* e *Setters*?

- **Getter** = método que lê (retorna) o valor de um atributo privado.
- **Setter** = método que altera (atribui) o valor de um atributo privado.

Eles fazem parte do padrão **encapsulamento:** escondem os campos (`private`) e expõem acesso controlado por métodos públicos.

**Exemplo:**

```java
public class Pessoa {
	private String nome;  // atributo privado
	
	// getter
	public String getNome() {
		return nome;
	}
	
	// setter
	public void setNome(String nome) {
		this.nome = nome;
	}
}
```

---
# Por que usar *Getter* e *Setters*?

1. **Encapsulamento / proteção:** evita que partes externas alterem campos diretamente.
2. **Validação:** você pode validar valores antes de atribuir.
3. **Controle de leitura/escrita** - torna somente leitura (`getter` sem `setter`) ou somente escrita (raro).
4. **Mudança de implementação**: é possível mudar a representação interna sem afetar quem usa a classe.
5. **Compatibilidade com frameworks:** muitos frameworks (JavaBeans, ORM, serialização, bibliotecas JSON) dependem da convenção de getters/setters.

---
# Convenções de nome (JavaBeans)

Seguem a **convenção JavaBeans** (muito usada por frameworks):

- Getter para campo `x`: `public Tipo getX()`
- Setter para campo `x`: `public void setX(Tipo x)`
- Para **boolean** (primitivo), é com usar `is`: 
	- `public boolean isAtivo()` ou `public boolean getAtivo()` (ambos válidos, mas `is` é preferido).

- Nome do método: capitalize a primeira letra do nome do campo:
	- campo `nomeCompleto` → `getNomeCompleto()` / `setNomeCompleto(...)`

- Se o campo começa com duas letras maiúsculas (ex.: `URL`), mantenha a convenção consistente: `getURL()`.

---
# Regras de Sintaxe / Assinatura

## Getter

- Deve retornar o tipo do atributo.
- Não recebe parâmetros.

**Exemplo:**

```java
public int getIT(){
	return id;
}
```

## Setter

- Retorna `void` (ou `this` se for *fluent*).
- Recebe um parâmetro do tipo do atributo.

**Exemplo:**

```java
public void setId(int id) {
	this.id = id;
}
```

- `this` é usado para distinguir atributo do parâmetro quando o nome é igual.

---
# Exemplos

## 1. Validação no Setter

```java
public class Aluno {
	private double nota;
	
	public double getNota(){
		return nota;	
	}
	
	public double setNota(double nota){
		if (nota < 0 || nota > 10) {
			throw new IllegalArgumentException("Nota deve estar entre 0 e 10");
		}
		this.nota = nota;
	}
}
```

O setter protege a invariante da classe - garante que `nota` sempre fique sem um intervalo válido.

## 2. Somente Leitura (apenas Getter)

```java
public class Config {
	private final String idSistema;
	
	public Config(String id) {
		this.idSistema = id;
	}
	
	public String getIdSistema() {
		return idSistema;
	}
	
	// Sem setter → imutável externamente
}
```

Atributos `final` e sem `setter` criam objetos com propriedades imutáveis (ou somente inicializáveis via construtor).

## 3. *Defensive copy* para coleções

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Time {
	private fnal List<String> jogadores = new ArrayList<>();
	
	public List<String> getJogadores() {
		// retona cópia imutável para evitar modificações externa
		return Collections.unmodifiableList(new ArrayList<>(jogadores));
	}
	
	public void addJogador(String nome) {
		jodadores.add(nome);
	}
}
```

Se a lista interna for exposta diretamente (`return jogadores`), o código cliente pode modificar o conteúdo quebrando invariantes. *Defensive copy* previne isso.

## 4. *Fluente* Setters (encadeamento)

```java
public class Pessoa {
	private String nome;
	private ind idade;
	
	public Pessoa setNome(String nome) {
		this.nome = nome;
		return this; // permite encadear
	}
	
	public Pessoa setIdade(int idade) {
		this.idade = idade;
		return this;
	}
}
```

**Uso:**

```java
Pessoa p = new Pessoa().setNome("Maria").setIdade(23);
```

>[!note] Observação:
>Útil para builders e APIs com *fluent style*. Nem sempre recomendado para beans Java tradicionais.

## 5. Getters com lógica (*lazy init*)

```java
public class Recurso {
	private ExpensiveObject obj;
	
	public ExpensiveObject getObj() {
		if (obj == null) {
			obj = new ExpensiveObject(); // só cria quando necessário
		}
		return obj;
	}
}
```

Em ambientes concorrentes, precisa sincronização.

---
# Uso com frameworks e seriaçização

- **JavaBeans:** convenção de getters/setters é usada por JSP, JSF, frameworks de binding.
- **ORMs (Hibernate/JPA):** por padrão podem usar campos ou getters/setters para persistência, mas convenção importa.
- **Jackson/Gson:** bibliotecas de JSON dependem de getters/setters (ou de anotações) para mapear propriedades.
- Quando usar *reflection/binding*, seguir convenções evita surpresas.

---
# Boas práticas e recomendações

1. **Não exponha campos public** só para evitar escrever getters/setters — encapsule.
2. **Evite setters indiscriminados**: se a classe possui invariantes, restrinja ou remova setters.
3. **Prefira imutabilidade** quando possível (campos `final`, valores só via construtor).
4. **Valide em setters** (não apenas no código consumidor).
5. **Use defensive copies** ao expor coleções ou objetos mutáveis.
6. **Considere nível de acesso do setter**:
    - `public` para APIs públicas;
    - `protected` ou `package-private` para uso interno;
    - sem setter para somente leitura.

7. **Documente comportamentos**: se o getter calcula, faz lazy init, ou retorna cópia, deixe claro no JavaDoc. 
8. **Evite lógica pesada em getters** — getters são esperados ser leves; surpreender pode causar bugs (ex: side effects).
9. **Para boolean**, prefira `isX()`.

---
# Concorrência (*thread-safety*)

- Getters e setters simples são geralmente atômicos para tipos primitivos (exceto `long`/`double` em JVM antigos), mas não garantem consistência entre múltiplos campos.

- Para campos mutáveis ou init lazy em ambiente multithread:
    - use `synchronized`, `volatile`, `AtomicReference`, ou padrões de inicialização thread-safe.

```java
private volatile ExpensiveObject obj;
public ExpensiveObject getObj() {
    ExpensiveObject result = obj;
    if (result == null) {
        synchronized(this) {
            if (obj == null) obj = new ExpensiveObject();
            result = obj;
        }
    }
    return result;
}
```

---
# Alternativas e Recursos Modernos

- **Lombok** (`@Getter`, `@Setter`) - gera getters/setters em tempo de compilação

```java
@Getter @Setter
public class Pessoa {
	private String nome;
	private int idade;
}
```

*Prós:* menos boilerplate.
*Contras:* dependência de biblioteca e "mágica".


- **Java `record`** (Java 16+) - para classes imutáveis e concisas:

```java
public record Pessoa (String nome, int idade) {}
```

*Records* geram automaticamente componentes/ACESSORES (não chamados `getX()`, mas `nome()`/`idade()`), e não possuem setters (são imutáveis).

- **Public fields:** aceitável em classes internas ou DTOs simples onde encapsulamento não agrega valor, mas em geral desaconselhado em APIs públicas.

---
# Problemas comuns / armadilhas

1. Esquecer `this` - causa atribuição do parâmetro para ele mesmo:

```java
public void setNome(String nome) { 
	nome = nome; // BUG
}
```

2. **Expor coleções internas** - clientes modificam estado interno.
3. **Getters com *side effects*** - pegar causa alteração de estado, confunde quem lê.
4. **Nomes inconsistentes** - frameworks falham se você não seguir convenção JavaBeans.
5. **Usar `getBoolean()` vs `isBoolean()`** - prefira `is` para booleans, alguns frameworks espera `isX`.
6. **Serializable + transient** - cuidado se getters usam campos calculados que não são serializados.

---
# Exemplos integrados (classe completa com boas práticas)

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Curso {
    private final String codigo;         // imutável
    private String nome;
    private final List<String> alunos = new ArrayList<>();

    public Curso(String codigo, String nome) {
        if (codigo == null || codigo.isBlank()) throw new IllegalArgumentException("codigo inválido");
        this.codigo = codigo;
        this.nome = nome;
    }

    // getter imutável
    public String getCodigo() {
        return codigo;
    }

    // getter + setter com validação
    public String getNome() {
        return nome;
    }

    public void setNome(String nome) {
        if (nome == null || nome.isBlank()) throw new IllegalArgumentException("nome inválido");
        this.nome = nome;
    }

    // não expor a lista diretamente
    public List<String> getAlunos() {
        return Collections.unmodifiableList(new ArrayList<>(alunos));
    }

    // métodos de domínio (em vez de setter de lista inteira)
    public void matricular(String aluno) {
        if (aluno == null || aluno.isBlank()) throw new IllegalArgumentException("aluno inválido");
        alunos.add(aluno);
    }

    public void cancelarMatricula(String aluno) {
        alunos.remove(aluno);
    }
}
```

Campos críticos são protegidos, a lista é encapsulada, e operações são expostas por métodos de negócio ao invés de um setter que sobrescreve toda a lista.

---
# Checklist rápido: quando criar getters/setters

- Crie **getter** se precisar que código externo leia o valor.
- Crie **setter** somente se quiser permitir que código externo altere o valor.
- Se o campo deve ser imutável → **não crie setter**; inicialize via construtor e marque `final` se fizer sentido.
- Para coleções → **não retorne a coleção interna diretamente**; use `Collections.unmodifiableList` ou cópia defensiva.
- Para valores com regras → coloque validação no setter.

---
# Conclusão

- **Getters/setters** são o mecanismo padrão em Java para acessar e modificar atributos encapsulados.
- Eles permitem **controle, validação e flexibilidade**.
- Siga a **convenção JavaBeans** (`getX`, `setX`, `isX`) para compatibilidade com frameworks.
- Prefira **imutabilidade** quando possível; use setters com critério.
- Pense em **defensive copy**, **thread-safety** e **documentação** para evitar surpresas.