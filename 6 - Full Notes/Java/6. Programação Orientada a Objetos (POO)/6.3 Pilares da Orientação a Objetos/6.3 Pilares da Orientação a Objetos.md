2025-09-17 09:55

Status: #developed #Java 

Tags: [[Java]] | [[Programação Orientada a Objetos]] | [[3 - Tags/Java/Polimorfismo]] | [[Herança]] | [[Abstração]] | [[Encapsulamento]]

----
# Introdução

Além dos conceitos centrais do paradigma da Orientação a Objetos, existem alguns **outros conceitos** que são de extrema **importância** e que formam os pilares da Programação Orientada a Objetos:

- Polimorfismo
- Herança
- Abstração
- Encapsulamento

![[Pasted image 20250917095800.png]]

---
# Polimorfismo

Palavra de origem grega e que significa "várias formas". Por meio da implementação desse conceito, podemos fazer um **objeto** de uma determinada classe executar um **comportamento diferente** de acordo com algum **parâmetro passado**.

### Exemplo

Suponde que um dos motivos de você ter comprado um carro foi a qualidade do sistema de som dele.

Mas digamos que a reprodução só pode ser feita via rádio ou _bluetooth_, enquanto que no seu antigo carro, podia ser feita apenas via cartão SD e _pendrive_.

Em ambos os carros está presente o método "tocar música" mas, como o sistema de som deles é diferente, a forma como o carro toca as músicas é diferente.

Dizemos que o método "tocar música" é uma forma de **polimorfismo**, pois dois objetos, de duas classes diferentes, têm um mesmo método que é implementado de formas diferentes, ou seja, um método possui _várias formas_, várias implementações diferentes em classes diferentes, mas que possuem o mesmo efeito ("polimorfismo" vem do grego _poli_ = muitas, _morphos_ = forma).

```java
public class Main {
	public static void main(String[] args) {
		Automovel moto = new Moto("Yamaha XPTO-100", new MecanismoDeAceleracaoDeMotos())
		Automovel carro = new Carro("Honda Fit", new MecanismoDeAceleracaoDeCarros())
		List<Automovel> listaAutomoveis = Arrays.asList(moto, carro);
		for (Automovel automovel : listaAutomoveis) {
			automovel.acelerar();
			automovel.acenderFarol();
		}
	}
}
```

Repare que apesar de serem objetos diferentes, `moto` e `carro` possuem os mesmos métodos `acelerar` e `acenderFarol`, que são chamados da mesma forma, apesar de serem implementados de maneira diferente.

---
# Herança

É um mecanismo muito importante na Orientação a Objetos, no qual uma **classe** pode **herdar atributos e comportamentos** de uma outra classe. Por meio da herança conseguimos **reaproveitar o código**, podendo facilitar a implementação e a manutenção de classes no futuro.

### Exemplo 1

Digamos que você tenha comprado o modelo Fit, da Honda. Esse modelo possui uma outra versão, chamada WR-V (ou "Honda Fit Cross Style"), que possui muitos dos atributos da versão clássica, mas com algumas diferenças bem grandes para transitar em estradas de terra.

Diferente da versão clássica, o motor é híbrido, possui um sistema de suspensão diferente tração nas quatro rodas, por exemplo.

Vemos então que não só alguns atributos como também alguns mecanismos (ou métodos, traduzindo para POO) mudam.

No entanto, a versão "cross" ainda é do modelo Honda Fit, ou melhor, _é um tipo_ do modelo.

Quando dizemos que uma classe A _é um tipo de_ classe B, dizemos que a classe A _herda_ as características da classe B e que a classe B é _mãe_ da classe A, estabelecendo então uma relação de **herança** entre elas.

No caso do carro, dizemos então que um Honda Fit "Cross" _é um tipo de_ Honda Fit e o que muda são alguns atributos e um dos métodos da classe.

Mas todo o resto permanece o mesmo, e o novo modelo recebe os mesmos atributos e métodos do modelo clássico.

```java
// "extends" estabelece a relação de herança dom a classe Carro
public class HondaFit extends Carro {
	public HondaFit(MecanismoAceleracao mecanismoAceleracao) {
		String modelo = "Honda Fit";
		// chama o construtor da classe mãe, ou seja, da classe "Carro" 
		super(modelo, mecanismoAceleracao);
	}
}
```

### Exemplo 2

```java
public class Producao {
	public int id;
	public String nome;
	public String classificacao;
	public String diretor;
	public String estudio;
	public Date dataLancamento;
}
```

Agora vamos fazer uma classe herdar da class `Producao`:

```java
public class Serie extends Producao {
	public int temporadas;
	public Date dataEncerramento;
}
```

Em resumo, fizemos a classe `Serie` herdar de `Producao`. Mas, o que ela herda?

Pela herança, uma **classe derivada herda os atributos**, então `Serie` possui agora: `id`, `nome`, `classificaco`, etc. e também os comportamentos que foram definidos em `Producao`.

---
# Abstração

É um **processo mental**, é a atividade onde vamos definir **o que é importante para ser representado** em um sistema. Por exemplo: na definição de um sistema médico para acompanhamento de pacientes, pode ser necessário identificar o nome. CPF, data de nascimento, tipo sanguíneo, etc.

Já para um sistema de paciente no contexto de uma clínica de beleza, as informações essenciais podem ser: identidade, endereço, telefone de contato e e-mail.

>[!info] Nota:
>Este processo de identificar e analisar quais **informações** deverão ser **modeladas** em uma classe de um sistema é a **abstração**.

---
# Encapsulamento

Conceitualmente o encapsulamento é algo bem simples. A ideia aqui é conseguir **ocultar parte do código** para implementar a segurança a fim de qua a **modificação na estrutura** de um determinado **objeto** não afete outros em nosso sistema.

O [encapsulamento](https://www.alura.com.br/artigos/o-que-e-encapsulamento) de atributos e métodos impede o _vazamento de escopo_, em que um atributo ou método é visível por alguém que não deveria vê-lo, como outro objeto ou classe.

### Exemplo

Ainda usando a analogia do carro, sabemos que ele possui atributos e métodos. Ou seja, características e comportamentos.

Os métodos do carro, como acelerar e frear, podem usar atributos e outros métodos do carro como o tanque de gasolina e o mecanismo de injeção de combustível.

Afinal de contas, acelerar o carro gasta combustível.

![[Pasted image 20250917101909.png]]

No entanto, se alguns desses atributos ou métodos forem facilmente visíveis e modificáveis, como o mecanismo de aceleração do carro, é possível fazer alterações com efeitos colaterais imprevisíveis.

Nessa analogia, uma pessoa pode não estar satisfeita com a aceleração do carro e modifica a forma como ela acontece, criando efeitos colaterais que podem, por exemplo, fazer o carro nem andar. Dizemos, nesse caso, que o método de aceleração do seu carro não é visível por fora do próprio carro.

Na POO, um atributo ou método que não é visível de fora do próprio objeto é chamado de "privado" e quando é visível, é chamado de "público".

![[Pasted image 20250917102002.png]]

Mas então, como sabemos como o nosso carro acelera? É simples: não sabemos.

Nós só sabemos que para acelerar, devemos pisar no acelerador e de resto o objeto sabe como executar essa ação sem expor como o faz. Dizemos que a aceleração do carro está _encapsulada_, pois sabemos o que ele vai fazer ao executarmos esse método, mas não sabemos como - e na verdade, não importa para o programa como o objeto o faz, só que ele o faça.

O mesmo vale para atributos. Por exemplo, não sabemos como o carro sabe qual velocidade mostrar no velocímetro ou como ele calcula sua velocidade, mas não precisamos saber como isso é feito. Só precisamos saber que ele vai nos dar a velocidade certa. Ler ou alterar um atributo encapsulado pode ser feito a partir de _getters e setters_ (colocar referência). Isso evita a confusão do uso de variáveis globais no programa, deixando mais fácil de identificar em qual estado cada variável vai estar a cada momento do programa, já que a restrição de acesso nos permite identificar quem consegue modificá-la.

```java
public class Carro {
	private Double velodicade;
	private String modelo;
	private MecanismoAceleracao mecanismosAceleracao;
	private String cor;
/* Repare que o mecanismo de aceleração é inserido no carro ao ser construído, e não o vemos nem podemos modificá-lo, isto é, não tem getter nem setter. Já o "modelo" pode ser visto, mas não alterado. */

	public Carro(String modelo, MecanismoAceleracao mecanismoAceleracao) {
		this.modelo = modelo;
		this.mecanismoAceleracao = mecanismoAceleracao;
		this.velocidade = 0;
	}
	
	public void acelerar() {
	this.mecanismoAceleracao.acelerar();
	}

	public void frear() {
		/* código do carro para frear */
	}
	
	public void acenderFarol() {
		/* código do carro para acender o farol */
	}
	
	public Double getVelocidade() {
		return this.velocidade
	}
	
	private void setVelocidade() {
		/* código para alterar a velocidade do carro */
		/* Como só o próprio carro deve calcular a velocidade, esse método não pode ser chamado de fora, por isso é "private" */
	}
	
	public String getModelo() {
		return this.modelo;
	}
	
	public String getCor() {
		return this.cor;
	}
	
	/* podemos mudar a cor do carro quando quisermos */
	public void setCor(String cor) {
		this.cor = cor;
	}
}
```