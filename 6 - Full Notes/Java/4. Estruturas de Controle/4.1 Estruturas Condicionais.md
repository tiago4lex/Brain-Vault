2025-09-20 08:35

Status: #developed #Java 

Tags: [[Java]]

----
# Introdução

Estruturas condicionais permitem que o programa escolha entre caminhos diferentes dependendo de expressões booleanas. Em Java as principais são:

- `if`, `if-else`, e encadeamento `else if`.
- `switch` (declaração tradicional e *switch expressions* / sintaxe moderna).
- operador ternário (`?:`)

Além disso, o uso correto de operadores lógicos (`&&`, `||`, `!`) e de curto-circuito é parte essencial do raciocínio condicional.

---
# `if`, `if-else`, `else if`

## Sintaxe básica

```java
if (condicao) {
	// executa se a condição for verdadeira (true)
} else {
	// executa se a condição for falsa (false)
}
```

## Encadeamento (`else if`)

```java
if(nota >= 90) {
	System.out.println("A");
} else if (nota >= 80) {
	System.out.println("B");
} else if (nota >= 70) {
	System.out.println("C");
} else {
	SYstem.out.println("D ou F");
}
```

### Exemplo

```java
int nota = 85;
if (nota >= 90) {
    System.out.println("A");
} else if (nota >= 80) {
    System.out.println("B"); // saída: B
} else {
    System.out.println("Outros");
}
```

## Quando usar?

- Quando as condições são **expressões booleanas** simples ou compostas.
- Quando os ramos dependem de intervalos, comparações numéricas, verificações arbitrárias.

## Vantagens

- Simples e explícito.
- Fácil de ler para casos com poucas condições.

## Desvantanges

- Muitos `else if` podem ficar verbosos e difíceis de manter.
- Aninhamento profundo reduz legibilidade

---
# `switch` (declaração tradicional)

## Sintaxe clássica

```java
switch(valor) {
	case 1:
		// ...
		break;
	case 2:
		// ...
		break;
	default:
		// ...
}
```

## Exemplo com `String` e `enum`

```java
String dia = "SEGUNDA";
switch (dia) {
	case "SEGUNDA":
	case "TERÇA":
		System.out.printlm("Dia de semana");
		break;
	case "SÁBADO":
	case "DOMINGO":
		System.out.prinln("Fim de semana");
		break;
	default:
		System.out.println("Outro");
}
```

É possível usar `switch` com `int`, `char`, `String` e `enum` (entre outros tipos de constantes).

## *Fall-Through* (comportamento de "queda")

Sem `break` o fluxo "cai" para o próximo `case` - isso pode ser útil, mas é fonte comum de bugs.

## Quando usar?

- Quando se tem **muitos ramos discretos** baseados em valores constantes (por exemplo, comandos, códigos, `enums`).
- Quando queremos comportamento eficiente e claro para casos por valor.

## Vantagens

- Mais claro que muitos `else if` quando os testes são sobre um único valor.
- `switch` sobre `enums` melhora legibilidade e segurança de tipo.

## Desvantagens

- Para condições complexas (intervalos, expressões booleanas compostas), `switch` não é apropriado.
- *Fall-through* acidental é uma armadilha.

---
# `switch` moderno (*expressions / arrow labels*)

Sintaxe mais concisa disponível em versões modernas de Java (*arrow labels* `->` e `switch` como expressão).

```java
int dia = 2;
String nome = switch (dia) {
	case 1 -> "Doming";
	case 2 -> "Segunda";
	default -> "Outro";
};
```

Ou com múltiplos labels:

```java
switch (comando) {
	case "start", "run" -> startService();
	case "stop" -> stopService();
	default -> System.out.println("comando in´valido");
}
```

## Vantagem

- Evita *fall-through* e facilita retorno de valores diretamente do `switch`.

---
# Operador ternário (`?:`)

## Sintaxe

```java
resultado = condicao ? valorSeTrue : valorSeFalse;
```

## Exemplo

```java
int a = 10, b = 20;
int maior = (a > b) ? a : b; // maior = 20
```

## Quando usar?

- Para expressões simples e curtas que retornam um valor com base em uma condição.
- Boa prática: usar apenas quando a expressão é simples; evita uso em expressões longas/complexas para não prejudicar a legibilidade.

## Vantagens

- Sintaxe compacta para atribuições condicionais.

## Desvantagens

- Pode ficar ilegível com ternários aninhados.

---
# Operadores lógicos e curto-circuito

## Principais operadores

- `&&` (AND lógico; curto-circuito)
- `||` (OR lógico; curto-circuito)
- `!` (NOT)
- `&` e `|` também existem: **sem** curto-circuito quando aplicados a booleanos (avaliam ambos os operadores)

## Exemplo de curto-circuito

```java
String s = null;
if (s != null && s.length() > 0) {
	// s.lentgh() só é chamado se s !=null for true
	System.out.println("tem conteúdo");
}
```

Se `&` fosse usado ao invés de `&&`, `s.length()` seria chamado mesmo quando `s` for `null`, causando `NullPointerException`.

## Quando usar

- Use `&&` e `||` na maioria dos casos; só use `&`/`|` quando a avaliação de ambos os lados for necessária por efeito colateral (raro).

---
# `instanceof` com *pattern matching* (forma moderna)

Exemplo prático e seguro:

```java
Object obj = "texto";
if (obj instanceof String s) {
	System.out.println(s.toUpperCase()); // s já é String aqui
}
```

Este método evita cast explícito e é mais conciso.

---
# Boas práticas e padrões de uso

## 1. Prefira clareza sobre micro-otimizações

Legibilidade é mais importante do que "economizar algumas operações". O compilador/JVM e a CPU já otimizam muito.

## 2. Evite aninhamentos profundos.

Se houver muitos níveis de `if` aninhados, considere:

- *Guard clauses* (retorno antecipado).
- Refatorar em métodos menores.
- Usar *polymorphism/strategy pattern*

#### *Guard clause (early return)*

```java
public void process(Objeto o) {
	if (o == null) return; // guarda e evita ifs aninhados
	// resto do processamento
}
```

## 3. Use `switch` para muitos ramos discretos ou `enums`

Quando a lógica depende de um único valor entre várias opções, `switch` (especialmente *switch expression* moderno) é mais claro.

## 4. Compare Strings corretamente

Nunca use ` == ` para conteúdo de Strings; use `equals` ou `Object.equals` para segurança com `null`:

```java
if ("sim".equalsIgnoreCase(resposta)) { ... }
if (Object.equals(a, b)) { ... } // null safe
```

## 5. Evite lógica com muitos efeitos colaterais dentro das condições

Condicional deve testar - não realizar muitas ações com efeitos colaterais. Isso melhora testabilidade.

## 6. Prefira `enums` para conjuntos fechados de opções

`Enums` com `switch` fornecem segurança e permite tratamento centralizado:

```java
enum Status { NOVO, PROCESSANDO, CONCLUIDO }
switch (status) {
	case NOVO -> ...
}
```

## 7. Substitua `else if` muito extenso por tabela de funções (`Map` + lambdas)

Quando cada caso realiza uma ação diferente sem compartilhar estado, `Map<String, Runnable>` pode ser mais mantível:

```java
Map<String, Runnable> acoes = Map.of(
	"start", () -> start(),
	"stop", () -> stop()
);

acoes.getOrDefault(comando, () -> System.out.println("inválido")).run();
```

---
# Armadilhas comuns e com evitá-las

1. **Divisão inteira acidental**  
    `percentual / 100` com `percentual` inteiro retorna zero. Use `100.0` ou faça cast: `(double) percentual / 100`.

2. **` == ` com objetos**  
    ` == ` compara referência; para comparar conteúdo use `equals`.

3.  **Fall-through no `switch`**  
    Esquecer `break` em `switch` tradicional causa execução de próximos `case`. Use `break` ou a sintaxe moderna com `->`.

4. **Uso errado de `&` e `|`**  
    `&` e `|` avaliam ambos os lados; prefira `&&` e `||` para evitar efeitos colaterais indesejados.

5. **Variáveis não inicializadas**  
    Em blocos condicionais, garanta que variáveis locais sejam inicializadas em todos os caminhos antes do uso.

6. **Condições complexas em `switch`**  
    `switch` trabalha com correspondência por valor; para intervalos use `if`/`else if`.

7. **Comparações de ponto flutuante**  
    Comparar `double` ou `float` com ` == ` é perigoso por imprecisão; use tolerância (epsilon).

---
# Exemplos práticos de refatoração

### Exemplo: muitos `else if` → `switch` (quando apropriado)

**Antes:**

```java
if (acao.quals("start")) start();
else if (acao.equals("stop")) stop();
else if (acao.equals("pause")) pause();
else defaultAction();
```

Depois (switch moderno):

```java
switch (acao) {
	case "start" -> start();
	case "stop" -> stop();
	case "pause" -> pause();
	default -> defaultAction();
}
```

### Exemplo: `if` com comportamento diferente → *Strategy* (polimorfismo)

Quando cada ramo usa lógica complexa diferente, coloque cada comportamento em uma classe que implemente uma interface e seleciona pela `enum`/`Map` - isso melhora test e manutenção.

---
# Tabela de referência rápida

| Estrutura                | Uso ideal                           | Vantagem                       | Desvantagem                    |
| ------------------------ | ----------------------------------- | ------------------------------ | ------------------------------ |
| `if` / `if-else`         | Comparações e intervalos            | Simples e direto               | Verboso com muitos ramos       |
| `else if`                | Sequência de condições relacionadas | Sequencial e claro             | Pode crescer demais            |
| `switch` (tradicional)   | Comparação por valor constante      | Limpo para muitos casos        | Fall-through pode causar bugs  |
| `switch` (moderno)       | Mesma finalidade, mais seguro       | Evita fall-through; expressões | Requer Java moderno            |
| Ternário `?:`            | Atribuição condicional simples      | Sintaxe curta                  | Ruim para lógica complexa      |
| `instanceof` com pattern | Verificação + cast seguro           | Menos cast explícito           | Disponível em versões modernas |

---
# Conclusão

- Use `if`/`else if` quando as condições envolvem intervalos, comparações complexas ou lógica composta.
    
- Use `switch` quando as decisões partem de um **único** valor discreto (especialmente enums e strings) — prefira a sintaxe moderna se disponível.
    
- Use o operador ternário apenas para expressões simples e curtas.
    
- Prefira guard clauses e métodos pequenos para reduzir aninhamento e melhorar legibilidade.
    
- Quando a lógica crescer demais, considere padrões de projeto (Strategy, Command) ou tabelas de ação (`Map`) em vez de longos blocos condicionais.