2025-09-17 08:19

Status: #developed #Java 

Tags: [[Java]] | [[Variáveis]] | [[Constantes]]

----
# Conceito Básico

## Variável

Um nome que referencia um valor (ou uma referência a um objeto). Serve para armazenar dados que podem mudar durante a execução do programa.

## Constante

Uma variável cujo valor não pode ser alterado depois de atribuído. Em Java usa-se a palavra-chave `final` (normalmente junto com `static`) para criar constantes;

---
# Tipos de dados relevantes

## Tipos primitivos

`byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean` → Armazenam valores simples diretamente (não objetos).

## Tipos de referência

Qualquer classe (por exemplo `String`, `Integer`, `List<MyObj>`) é um tipo de referência: a variável armazena **uma referência** ao objeto que está na heap.

---
# Sintaxe de declaração e inicialização

```java
// declaração sem inicialização (apenas em campos/atributos)
private int idade;

// declaração com inicialização
int contador = 0;

// declração múltipla
int a = 1, b = 2, c;
```

**Regras importantes:**

- **Campos/atributos** (variáveis de instância e estáticas) recebem **valores default** se não inicializados (ex.: `int` → `0`, `boolean` → `false`, referências → `null`).
- **Variáveis locais** (dentro de métodos) **não** têm valor default: é preciso inicializá-las antes de usar, caso contrário o compilador dá erro.

## Exemplo de erro com local não inicializado

```java
public void exemplo() {
	int x;                 // não inicializado
	System.out.println(x); // ERRO de compilação: variável local x pode não ter sido inicializado
}
```

## Forma Correta

### 1. Inicializar no momento de declaração

```java
public void exemplo() {
	int x = 0;              // inicializado
	System.out.println(x);  // imprime 0
}
```

### 2. Inicializar antes do uso (condicionalmente seguro)

Se a inicialização ocorrer dentro de um `if`, o compilador precisa ter **certeza** de qua variável será inicializada em todos os caminhos de execução:

```java
public void exemplo() {
	int x;
	boolean cond = true;
	
	if (cond) {
		x = 10;
	} else {
		x = 20;
	}
	
	System.out.println(x); // válido, pois x sempre será inicializado
}
```

Se houver a possibilidade de o `if` não atribuir valor, o compilador não aceita:

```java
public void exemplo() {
	int x;
	if (true) {
		x = 10;
	}
	System.out.println(x); // ERRO: pode não ter sido inicializado se o if for false
}
```

---
# Escopo e tempo de vida

### Variável Local

- Declarada dentro de um método/bloco;
- Existe enquanto a execução estiver dentro daquele bloco;
- Armazenada na stack (a referência ou valor).

### Atributo de Instância *(field)*

- Declarada na classe sem `static`;
- Existe enquanto o objeto existir  (no heap);

### Atributo de Classe *(static)*

- Declarado com `static`;
- Existe enquanto a classe estiver carregada pelo JVM (uma cópia por classe).

### Parâmetros de Método

- Considerados variáveis locais;
- Inicializados ao chamar o método.

---
# `final` - Criando Constantes

## `final` em variáveis

- `final` indica que a **referência** (ou valor no caso de primitivos) não pode ser alterada de pois da primeira atribuição.
- Para campos, costuma-se combinar com `static` para criar constantes de classe.

```java
public static final int MAX_USERS = 100;
public final String nome; // precisa ser inicializado no construtor
```

>[!info] Observação Importanta:
>- `final` sobre um **tipo de referência** impede reatribuir a variável para outro objeto, **mas não impede** modificar o estado interno do objeto se ele for mutável:
>  
>```java
public static final int[] VALORES = {1, 2, 3};
VALORES[0] = 99; // válido — o array é mutável
VALORES = new int[]{}; // inválido — não se pode reatribuir variável final
>```

## Constantes em tempo de compilação

- `public static final` de tipos primitivos ou `String` com expressão constante são **constantes em tempo de compilação** - o compilador pode **inline** (substituir o valor no bytecode do cliente). Isso tem implicações de compatibilidade binária: alterar o valor na biblioteca não alterará código que já foi compilado contra a versão antiga, a menos que esse código seja recompilado.

---
# `static` - Variável de Classe

- `static` torna a variável pertencente à **classe**, não a instâncias.
- Um único espaço na memória para todos os objetos da classe.

```java
public class Contador {
	public static int totalInstancias = 0;
	public Contador () {
		totalInstancias++;
	}
}
```

---
# `var` (inference de tipo local)

- Desde Java 10 existe `var` para **inferência de tipo em variáveis locais:**
	- Só funciona em variáveis locais com inicialização.
	- Não pode ser usado para campos, parâmetros ou variáveis não inicializadas.
	- O tipo é inferido pelo compilador e é estático (não é tipagem dinâmica).

```java
var lista = new ArrayList<String>(); // compilador trata como ArrayList<String>
```

---
# `volatile` (nota avançada)

- Palavra-chave usada para variáveis compartilhadas entre threads.
- Garante leitura/escrita diretamente na memória principal (sem cache thread-local), ajudando na visibilidade entre threads.
- Não substitui sincronização para operações compostas (por exemplo `count++` não é atômico só com `volatile`).

---
# Onde os valores vivem (memória)

- **Primitivos locais**: tipicamente na stack (quando aplicável).
- **Referências locais**: referência na stack; objeto real na heap.
- **Objetos**: heap.
- **Static fields**: área de memória da classe (Method Area / metaspace dependendo da JVM).

---
# Exemplos Práticos

## Exemplo 1 - campos, locais, static e final

```java
public class Pessoa {
	public static final double PI = 3.14159; // constante
	private static int totalPessoas = 0;     // variável de classe
	
	private String nome;
	private final int id;
	
	public Pessoa(String nome, int id) {
		this.nome = nome;
		this.id = id; // final inicializado no construtor
		totalPessoas++;
	}
	
	public void setNome(String nome) {
		this.nome = nome; // permitido
	}
}
```

## Exemplo 2 - final com referência mutável

```java
import java.util.ArrayList;
import java.util.List;

public class ExemploFinal {
	public static final List<String> nomes = new ArrayList<>();
	
	public static void main(String[] args) {
		nomes.add("Ana"); // OK - modifica conteúdo da lista
		// nomes = new ArrayList<>(); // ERRO de compilação - não permite reatribuição
	}
}
```

## Exemplo 3 - local não inicializado (erro)

```java
public void erroLocal() {
	int x;
	if (someCond()) {
		x = 10;
	}
	System.out.println(x); // Erro se someCond() for false: x pode não ter sido inicializada
}
```

---
# Boas práticas e convenções

- Nomes de variáveis: `camelCase` (ex.: `contadorItens`).
- Nomes de constantes: `UPPER_CASE_WITH_UNDERSCORES` (ex.: `MAX_RETRY`).
- Use `private` para atributos e exponha via getters/setters quando necessário.
- Prefira imutabilidade onde fizer sentido (`final` em campos e objetos imutáveis).
- Evite variáveis `static` mutáveis quando possível (dificulta testes e concorrência).
- Inicialize variáveis locais explicitamente antes de usar.

---
# Erros e armadilhas comuns

- **Usar variável local sem inicializar** → erro de compilação.
- **Achar que `final` torna o objeto imutável** → final só protege a referência.
- **Modificar constantes inlined por bibliotecas** → lembre que `public static final` primitivo/String pode ter sido inlined; atualizar só a biblioteca não altera código já compilado (recompile o cliente).
- **Conflito entre `java` e `javac` versões** → garanta que `JAVA_HOME` e `PATH` apontem corretamente.
- **Usar `var` sem inicialização** → erro de compilação.

---
# Resumo rápido das palavras-chave (uso)

- `int`, `double`, `boolean`, `char`, etc.: definem tipos primitivos.
- `String`: tipo referência comum (classe).
- `final`: impede reatribuição da variável (cria constantes).
- `static`: variável de classe (uma por classe).
- `public/private/protected`: controle de acesso (especifica visibilidade).
- `var`: inferência de tipo para variáveis locais (desde Java 10).
- `volatile`: garante visibilidade entre threads (usado em concorrência).