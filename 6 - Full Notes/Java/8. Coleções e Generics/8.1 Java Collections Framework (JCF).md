2025-11-11 12:21

Status: #developed #Java 

Tags: [[Java]]

----
# O que é Java Collections Framework (JCF)

O **Java Collections Framework** (JCF) é um conjunto de classes e interfaces que fornecem estruturas de dados e algoritmos prontos para o desenvolvedor.
Ele faz parte do pacote `java.util` e serve para **armazenar, manipular e organizar grupos de objetos** de forma eficiente e flexível.

Antes do JCF (nas versões antigas do Java), era necessário criar manualmente estruturas como listas, pilhas ou filas.

Com o JCF, o Java Passou a ter **implementações padronizadas** para essas estruturas, o que facilita muito o desenvolvimento.

---
# Principais Interfaces do Framework

As interfaces são o **núcleo do JCF**, definindo comportamentos gerais das coleções.
Cada implementação (classe concreta) pode ter comportamentos específicos.

|Interface|Descrição|Exemplo de Implementações|
|---|---|---|
|**Collection**|Interface base de quase todas as coleções. Define operações genéricas como adicionar, remover e verificar elementos.|—|
|**List**|Coleção **ordenada** que permite elementos duplicados.|`ArrayList`, `LinkedList`, `Vector`|
|**Set**|Coleção que **não permite elementos duplicados**.|`HashSet`, `LinkedHashSet`, `TreeSet`|
|**Queue**|Representa uma **fila** (FIFO).|`LinkedList`, `PriorityQueue`|
|**Deque**|Representa uma **fila dupla** (pode adicionar/remover de ambos os lados).|`ArrayDeque`|
|**Map**|Armazena **pares chave-valor** (como um dicionário).|`HashMap`, `LinkedHashMap`, `TreeMap`, `Hashtable`|

---
# Hierarquia Simplificada do JCF

```mathematica
              Iterable
                  │
              Collection
     ┌────────────┼─────────────┐
    List         Set          Queue
     │            │             │
 ArrayList     HashSet      LinkedList
 LinkedList    TreeSet      PriorityQueue

                 Map
     ┌────────────┼─────────────┐
   HashMap     LinkedHashMap   TreeMap
```

---
# Interface Collection

A interface `Collection<E>` define métodos comuns a todas as coleções.

**Principais métodos:**

```java
boolean add(E e);
boolean remove(Object o);
boolean contains(Object o);
int size();
boolean isEmpty();
void clear();
Iterator<E> iterator();
```

---
# Interface List e suas implementações

## `ArrayList`

É uma lista **baseada em array dinâmico**.

Permite acesso rápido a elementos pelo índice, mas **inserções e remoções no meio são mais lentas**.

```java
import java.util.ArrayList;

public class ExemploArrayList {
	public static void main(String[] args) {
		ArrayList<String> nomes = new ArrayList<>();
		
		nomes.add("Ana");
		nomes.add("João");
		nomes.add("Maria");
		
		System.out.prinln(nomes.get(1)); // Acessa "João"
		
		nomes.remove("Ana");
		System.out.println(nomes); // [João, Maria]
	}
}
```

**O que acontece:**

- `add()` insere elementos no final da lista.
- `get(1)` retorna o elemento no índice 1.
- `remove()` apaga um elemento específico.
- A lista é impressa com o método `toString()` sobreescrito pela classe.

## `LinkedList`

É uma **lista duplamente encadeada** — cada elemento sabe quem é o anterior e o próximo.

Melhor desempenho em **remoções e inserções**, mas mais lenta em **acessos diretos**.

```java
import java.util.LinkedList;

public class ExemploLinkedList {
    public static void main(String[] args) {
        LinkedList<Integer> numeros = new LinkedList<>();

        numeros.add(10);
        numeros.add(20);
        numeros.addFirst(5);  // adiciona no início
        numeros.addLast(30);  // adiciona no final

        System.out.println(numeros); // [5, 10, 20, 30]
    }
}
```

**O que acontece:**

- A `LinkedList` manipula ponteiros internos que ligam os nós da lista.
- Assim, inserir ou remover no início/fim é rápido, pois não há realocação de memória.

---
# Interface Set

Conjuntos que não permite elementos duplicados.

## `HashSet`

Armazena elementos **sem ordem específica** e usa **tabelas hash**.

```java
import java.util.HashSet;

public class ExemploHashSet {
	public static void main(String[] args) {
		HashSet<String> frutas = new HashSet<>();
		
		frutas.add("Maçã");
		frutas.add("Banan");
		frutas.add("Maçã"); // Ignorado, já existe
		
		System.out.println(frutas); // [Banana, Maçã]
	}
}
```

**O que acontece:**

- `HashSet` usa o `hashCode()` dos objetos para determinar onde armazenar cada item. Quando "Maçã" é adicionado novamente, ele detecta duplicação e ignora.

## `TreeSet`

Mantém os elementos **ordenados** automaticamente (ordem natural ou definida por `Comparator`).

```java
import java.util.TreeSet;

public class ExemploTreeSet {
	public static void main(String[] args) {
		TreeSet<Integer> numeros = new TreeSet<>();
		
		numeros.add(30);
		numeros.add(10);
		nuemros.add(20);
		
		System.out.printl(numeros); // [10, 20, 30]
	}
}
```

**O que acontece:**

- O `TreeSet` utiliza uma **árvore binária balanceada** (Red-Black Tree).
- Assim, os elementos são armazenados em **ordem crescente** por padrão.

---
# Interface Map (chave-valor)

## `HashMap`

Estrutura que associa **chaves únicas a valores**.

É uma das coleções mais usadas no JCF.

```java
import java.uitl.HashMap;

public class ExemploHashMap {
	public static void main(String[] args) {
		HashMap<String, Integer> idades = new HashMap<>();
		
		idades.put("Ana", 25);
		idades.put("João", 30);
		idades.put("Maria", 22);
		
		System.out.println(idade.get("João")); // 30
		
		idades.remove("Ana");
		System.out.println(idades); // {Maria=22, João=30}
	}
}
```

**O que acontece:**

- `put()` insere um par chave-valor.
- `get()` retorna o valor associado à chave.
- Se a chave já existir, o valor é substituído.
- A estrutura é **rápida**, pois usa **hashing interno**.

---
# Iterando sobre coleções

Há várias formas de percorrer coleções.

## Usando for-each

```java
import java.util.Iterator;

Iterator<String> it = nomes.iterator();
while (it.hasNext()) {
	System.out.println(it.next());
}
```

**O que acontece:**

- `Iterator` fornece um mecanismo segura para percorrer coleções, permitindo inclusive remover elementos durante a iteração (`it.remove()`).

---
# Interface Comparable e Comparator

Essas interfaces permitem **ordenar coleções de objetos personalizadas**.

## Exemplo com `Comparable`

```java
import java.util.ArrayList;
import java.util.Collections;

class Pessoa implements Comparable<Pessoa> {
	String nome;
	int idade;
	
	Pessoa(String nome, int idade) {
		this.nome = nome;
		this.idade = idade;
	}
	
	@Override
	public int compareTo(Pessoa outra) {
		return Integer.compare(this.idade, outra.idade);
	}
	
	@Override
	public string toString() {
		return nome + " (" + idade + ")";
	}
}

public class ExemploComparable {
	public static void main(String[] args) {
		ArrayList<Pessoa> pessoas = new ArrayList<>();
		
		pessoas.add(new Pessoa("Ana", 25));
		pessoas.add(new Pessoa("João", 30));
		pessoas.add(new Pessoa("Maria", 20));
		
		Collections.sort(pessoas);
		System.out.println(pessoas);
		
	}
}
```

**Saída:**

```text
[Maria (20), Ana (25), João (30)]
```

**O que acontece:**

- A interface `Comparable` define como **comparar** dois objetos (`compareTo`).
- Aqui, a ordenação é feita pela idade, e `Collections.sort()` usa esse critério.

---
# Regras e Boas Práticas

## 1. Prefira Interfaces e Implementações

```java
List<String> lista = new ArrayList<>();
```

Assim, é fácil trocar `ArrayList` por `LinkedList`, se necessário.

## 2. Evite usar coleções não tipadas (sem generics)

```java
Lista lista = new ArrayList(); // má prática
```

Sempre use **generics**:

```java
List<String> lista = new ArrayList<>();
```

## 3. Use o tipo certo para a necessidade:

- `ArrayList`: acesso rápido, poucos inserts/removes no meio.
- `LinkedList`: muitas inserções/remoções.
- `HashSet`: evitar duplicatas, sem ordem.
- `TreeSet`: evitar duplicatas **com ordem**.
- `HashMap`: chave-valor, acesso rápido.

---
# Conclusão

O **Java Collections Framework** é essencial para qualquer desenvolvedor Java.  
Ele oferece **estruturas otimizadas, seguras e padronizadas** para manipulação de dados, reduzindo código repetitivo e erros.

Dominar as classes e interfaces do JCF é um passo fundamental para:

- escrever código mais limpo e eficiente;
- compreender algoritmos e estruturas de dados;
- lidar melhor com grandes volumes de informação em aplicações reais.