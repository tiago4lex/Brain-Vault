
2025-11-24 13:59

Status: #developed #Java 

Tags: [[Java]] | [[ArrayList]] | [[HashSet]] | [[HashMap]]

----
# Introdução

O ***Java Collections Framework* (JCF)** oferece diversas classes e interfaces para manipular coleções de dados de maneira eficiente.

Entre as classes mais utilizadas estão:
- `ArrayList` → lista dinâmica baseada em array.
- `HashSet` → conjunto que armazena elementos únicos utilizando tabelas de hash.
- `HashMap` → mapa que associa chaves a valores também usando hash.

Apesar de todas trabalharem com coleções, elas possuem **finaldiades diferentes, estruturas internas distintas, e vantagens específicas** dependendo do problema.

---
# Classe `ArrayList`

## Definição

`ArrayList` é a implementação mais famosa da interface `List`.
Ela representa uma **lista dinâmica**, semelhante a um vetor (array), **mas que cresce automaticamente**.

```java
List<String> nomes = new ArrayList<>();
```

## Características Internas

- Internamente, usa um **array redimensionável** de Object.
- Quando o array enche, é criado um novo array **maior** e os elementos são copiadas.
- Acesso por índice é **rápido** (O(1)).
- Inserção/remoção no meio da lista é **lenta** (O(n)), pois exige deslocar elementos.

## Sintaxe Básica

```java
ArrayList<String> lista = new ArrayList<>();
lista.add("A");
lista.add("B");
lista.add("C");
lista.remove("B");

System.out.println(lista); // [A, C]
```

## Exemplo

```java
import java.util.ArrayList;

public class ExemploArrayList {
	public static void main(String[] args) {
		ArrayList<Integer> numeros = new ArrayList<>();
		
		numeros.add(10); // índice 0
		numeros.add(20); // índice 1
		numeros.add(30); // índice 2
		
		System.out.println(numeros.get(1)); // 20
		
		numeros.add(1, 15); // desloca elementos para a direita
		System.out.println(numeros); // [10, 15, 20, 30]
	}
}
```

### O que acontece internamente

- Quando `add(1, 15)` é executado, elementos a partir do índice 1 são **movidos para a direita** para abrir espaço.
- Isso explique porque inserções no meio são custosas.

## ✅ Vantagens

- Acesso rápido a elementos via índice.
- Muito prático para listas que crescem ao longo do programa.
- Iteração rápida.
- É a coleção mais usada e mais simples.

## ❌ Desvantagens

- Inserir/remover no meio é lenteo.
- Consome mais memória que um array normal.
- Não é eficiente para operações de busca sem índice (precisa percorrer a lista).

## Quando usar `ArrayList`

- Quando é necessário acessar elementos frequentemente pelo **índice**.
- Quando a maior parte das inserções **ocorre no final da lista**.
- Quando a ordem deve ser preservada.
- Quando duplicatas são permitidas.

---
# Classe `HashSet`

## Definição

`HashSet` implemente a interface `Set`, representando um conjunto que:
- Não permite **duplicatas**.
- **Não mantém ordem**.
- Usa **tabela hash** para armazenar os elementos.

```java
Set<String> cores = new HashSet<>();
```

## Características Internas

- Usa o método `hashCode()` dos objetos para decidir onde armazená-los.
- Para verificar duplicidade, usa `hashCode()` e depois `equals()`.
- Operações **add, remove, contains** tendem a ser **muito rápidas** (O(1)).

## Exemplo

```java
import java.util.HashSet;

public class ExemploHashSet {
	public static void main(String[] args) {
		HashSet<String> set = new HashSet<>();
		
		set.add("Azul");
		set.add("Vermelho");
		set.add("Verde");
		set.add("Azul"); // ignorado
		
		System.out.println(set);
	}
}
```

**O oque acontece internamente:**

- Quando `"Azul"`é inserido pela segunda vez, o `HashSet` detecta que já existe um elemento com o **mesmo hash** e **mesmo conteúdo**, então ignora.
- A ordem mostrada no `println` não é previsível.

## ✅ Vantagens

- Extremamente rápido para procurar elementos (`contains`).
- Garante que elementos duplicados **não existam**.
- Ideal para filtros, validações e remoção de duplicados.

## ❌ Desvantagens

- **Não mantém a ordem**.
- Não permite acesso por índice.
- Depende fortemente de `hashCode()` bem implementado.

## Quando usar `HashSet`

- Quando é necessário **garantir unicidade** dos dados.
- Quando é necessário procurar rapidamente por um elemento.
- Quando a ordem **não importa**.
- Quando está limpando ou validando dados duplicados.

---
# Classe `HashMap`

`HashMap` implementa a interface `Map`, que armazena pares:

```css
chave → valor
```

Cada chave é **única**, mas valores pode ser repetidos.

```java
Map<String, Integer> idades = new HashMap<>();
```

## Características Internas

- Usa tabelas de hash.
- Cada chave gera uma posição (bucket) → o valor é armazenado lá.
- Se ocorrer colisão, o HashMap usa **listas encadeadas** ou **árvores vermelhas-negras** (desde Java 8).

## Exemplo

```java
import java.util.HashMap;

public class ExemploHashMap {
	public static void main(String[] args) {
		HashMap<String, Integer> mapa = new HashMap<>();
		
		mapa.put("Ana", 25);
		mapa.put("Bruno", 30);
		mapa.put("Carlos", 20);
		mapa.put("Ana", 26); // substitui valor anterior
		
		System.out.println(mapa.get("Ana")); // 26
		System.out.println(mapa.containsKey("Bruno")); // true
	}
}
```

**Oque acontece internamente:**

- A primeira vez que `"Ana"` é adicionada → chave criada.
- A segunda vez → o valor antigo **é substituído**, pois a chave deve ser única.
- Elementos não têm ordem garantida.

## ✅ Vantagens

- Acesso extremamente rápido (O(1)).
- Ideal para tabelas de configuração, armazenar objetos por chave, caches, etc.
- Chave única → evita duplicação indesejada.

## ❌ Desvantagens

- Não mantém ordem.
- Depende de `hashCode()` bem implementado.
- Operações podem ficar mais lentas se houver muitas colisões.

## Quando usar `HashMap`

- Quando for preciso **ligar um dado a uma chave** (Ex: nome → idade).
- Para buscas rápidas.
- Quando valores podem repetir, mas chaves não.
- Para representar tabelas, dicionários, registros.

---
# Comparação entre `ArrayList`, `HashSet`, `HashMap`

|Característica|ArrayList|HashSet|HashMap|
|---|---|---|---|
|Estrutura interna|Array dinâmico|Tabela de hash|Tabela de hash|
|Permite duplicatas?|Sim|Não|Chaves: não / Valores: sim|
|Mantém ordem?|Sim|Não|Não|
|Acesso por índice|Sim|Não|Não|
|Tipo de coleção|Lista|Conjunto|Mapa (chave/valor)|
|Rapidez leitura|Alta|Alta|Alta|
|Rapidez inserção|Alta (no final)|Alta|Alta|
|Rapidez remoção|Média|Alta|Alta|
|Uso comum|Listas ordenadas|Unicidade|Dicionários|

---
# Exemplos Práticos Comparativos

## Removendo elementos duplicados de uma lista

**Sem `HashSet`:**

```java
List<String> nomes = Arrays.asList("Ana", "Ana", "Bruno", "Carlos");
List<String> unicos = new ArrayList<>();

for (String n : nome) {
	if (!unicos.contains(n)) {
		unicos.add(n);
	}
}
```

Com `HashSet` (muito mais eficiente):

```java
Set<String> unicos = new HashSet<>(nomes);
```

## Contendo ocorrências com `HashMap`

```java
String texto = "a b c a b a";
String[] palavras = texto.split(" ");

HashMap<String, Integer> contador = HashMap<>();

for (String p : palavras) {
	contador.put(p, contador.getOrDefault(p, 0) + 1);
}

System.out.println(contador);
```

>[!note] Nota:
>Usar `Map` é ideal para "estatísticas", contagem, dicionários, etc.

## Lista dinâmica com `ArrayList`

```java
List<String> tarefas = new ArrayList<>();

tarefas.add("Estudar Java");
tarefas.add("Praticar exercícios");
tarefas.add("Fazer projeto");

tarefas.remove("Praticar exercícios");

System.out.println(tarefas);
```

---
# Conclusão

As classes `ArrayList`, `HashSet` e `HashMap` são fundamentais no Java Collections Framework porque oferecem soluções distintas e otimizadas para diferentes tipos de problema:

- `ArrayList` é ideal para listas ordenadas e com acesso por índice.
- `HashSet` garante **unicidade** e operações rápidas de busca.
- `HashMap` é perfeito para associar **chaves a valores**, como um dicionário.
