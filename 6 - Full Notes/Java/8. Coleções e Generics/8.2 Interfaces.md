2025-11-11 12:59

Status: #developed #Java 

Tags: [[Java]] | [[List]] | [[Set]] | [[Map]]

----
# Introdu√ß√£o

O **Java Collections Framework (JCF)** organiza e padroniza as principais estruturas de dados em Java.

Tr√™s das interfaces mais importantes s√£o:

- `List` ‚Üí cole√ß√µes **ordenadas** e **indexadas**.
- `Set` ‚Üí cole√ß√µes **sem elementos duplicados**.
- `Map` ‚Üí cole√ß√µes de **pares chave-valor**.

Cada uma tem **implementa√ß√µes diferentes** que se adequam a necessidades espec√≠ficas, como **ordena√ß√£o, rapidez de busca, inser√ß√£o, ou garantia de unicidade**.

---
# Interface `List`

## Defini√ß√£o

A interface `List<E>` representa uma **cole√ß√£o ordenada** de elementos, em cada item tem uma **posi√ß√£o** (√≠ndice).

Ela **permite duplicatas**, ou seja, √© poss√≠vel ter dois elementos iguais na lista.

- **Pacote:** `java.util.List`
- **Superinterface:** `Collection<E>`

## Principais Implementa√ß√µes

| Implementa√ß√£o | Caracter√≠sticas                                                                        |
| ------------- | -------------------------------------------------------------------------------------- |
| `ArrayList`   | Baseada em array din√¢mico. R√°pida para leitura. Inser√ß√µes/remo√ß√µes no meio s√£o lentas. |
| `LinkedList`  | Baseada em lista duplamente encadeada. Boa para inser√ß√µes/remo√ß√µes.                    |
| `Vector`      | Similar ao `ArrayList`, mas **sincronizado** (antigo, pouco usado hoje).               |
| `Stack`       | Subclasse de `Vector` usada como **pilha** (LIFO).                                     |

## Sintaxe B√°sica

```java
List<String> nomes = new ArrayList<>();

nomes.add("Ana");
nomes.add("Jo√£o");
nomes.add("Maria");

System.out.println(nomes.get(1)); // Jo√£o
```

## M√©todos Comuns

| M√©todo                | Descri√ß√£o                                |
| --------------------- | ---------------------------------------- |
| `add(E e)`            | Adiciona elemento no final.              |
| `add(int index, E e)` | Adiciona em uma posi√ß√£o espec√≠fica.      |
| `get(int index)`      | Retorna elemento no √≠ndice.              |
| `set(int index, E e)` | Substitui o elemento do √≠ndice.          |
| `remove(int index)`   | Remove elemento pelo √≠ndice.             |
| `indexOf(Object o)`   | Retorna o √≠ndice da primeira ocorr√™ncia. |
| `size()`              | Retorna o tamanho da lista.              |

## Exemplo Explicado: `ArrayList`

```java
import java.util.ArrayList;
import java.util.List;

public class ExemploList {
    public static void main(String[] args) {
        List<String> frutas = new ArrayList<>();

        frutas.add("Ma√ß√£");
        frutas.add("Banana");
        frutas.add("Laranja");
        frutas.add("Banana"); // duplicado permitido

        frutas.remove("Ma√ß√£");
        System.out.println("Lista: " + frutas);
        System.out.println("Primeiro elemento: " + frutas.get(0));
    }
}
```

**Sa√≠da:**

```
Lista: [Banana, Laranja, Banana]
Primeiro elemento: Banana
```

**O que acontece:**

- O `ArrayList` cria um array din√¢mico que cresce conforme necess√°rio.
- Elementos s√£o acessados por **√≠ndice** (`get(0)` ‚Üí primeiro elemento).
- O m√©todo `remove()` desloca os elementos seguintes para preencher o espa√ßo removido.

## Exemplo Explicado: `LinkedList`

```java
import java.util.LinkedList;
import java.util.List;

public class ExemploLinkedList {
    public static void main(String[] args) {
        List<Integer> numeros = new LinkedList<>();

        numeros.add(10);
        numeros.add(20);
        numeros.add(30);
        numeros.add(1, 15); // insere no √≠ndice 1

        System.out.println(numeros); // [10, 15, 20, 30]
    }
}
```

**Sa√≠da:**

```
[10, 15, 20, 30]
```

**O que acontece:**

- A `LinkedList` n√£o usa √≠ndices internamente, mas sim **n√≥s encadeados**.    
- Inser√ß√µes no meio s√£o r√°pidas, pois apenas os ponteiros dos n√≥s s√£o ajustados.

## Quando usar `List`

Use `List` quando voc√™:

- Precisa **acessar elementos por √≠ndice**;
- Precisa **manter a ordem de inser√ß√£o**;
- Pode ter **elementos duplicados**;
- Precisa **inserir ou remover** elementos dinamicamente.

---
# Interface `Set`

## Defini√ß√£o

A interface `Set<E>` representa um **conjunto** ‚Äî uma cole√ß√£o **sem elementos duplicados**.

Os elementos podem (ou n√£o) **estar ordenados**, dependendo da implementa√ß√£o.

- **Pacote:** `java.util.Set`.
- **Superinterface:** `Collections<E>`.

## Principais Implementa√ß√µes

|Implementa√ß√£o|Caracter√≠sticas|
|---|---|
|`HashSet`|Usa tabela de espalhamento (hash). N√£o mant√©m ordem.|
|`LinkedHashSet`|Mant√©m **ordem de inser√ß√£o**.|
|`TreeSet`|Mant√©m elementos **ordenados automaticamente** (ordem natural ou via `Comparator`).|

## Sintaxe B√°sica

```java
Set<String> nomes = new HashSet<>();

nomes.add("Ana");
nomes.add("Jo√£o");
nomes.add("Ana"); // ignorado (duplicado)

System.out.println(nomes);
```

## M√©todos Comuns

|M√©todo|Descri√ß√£o|
|---|---|
|`add(E e)`|Adiciona elemento (ignora duplicado).|
|`remove(Object o)`|Remove elemento.|
|`contains(Object o)`|Verifica se existe.|
|`size()`|Retorna o tamanho.|
|`isEmpty()`|Verifica se est√° vazio.|
|`clear()`|Limpa o conjunto.|

## Exemplo Explicado: `HashSet`

```java
import java.util.HashSet;
import java.util.Set;

public class ExemploSet {
    public static void main(String[] args) {
        Set<Integer> numeros = new HashSet<>();

        numeros.add(10);
        numeros.add(20);
        numeros.add(10); // duplicado ignorado

        System.out.println(numeros);
    }
}
```

**Sa√≠da:**

```
[20, 10]
```

**O que acontece:** 

- O `HashSet` usa o **m√©todo `hashCode()`** de cada objeto para decidir onde armazen√°-lo.  
- Quando o mesmo valor √© adicionado novamente, o hash √© o mesmo, e o objeto √© ignorado.

## Exemplo Explicado: `TreeSet` (ordenado)

```java
import java.util.TreeSet;
import java.util.Set;

public class ExemploTreeSet {
    public static void main(String[] args) {
        Set<String> nomes = new TreeSet<>();
        nomes.add("Carlos");
        nomes.add("Ana");
        nomes.add("Bruna");

        System.out.println(nomes);
    }
}
```

**Sa√≠da:**

```
[Ana, Bruna, Carlos]
```

**O que acontece:**

- O `TreeSet` usa uma **√°rvore bin√°ria balanceada (Red-Black Tree)** para manter os elementos **ordenados**.  
- A ordena√ß√£o √© feita de forma autom√°tica, de acordo com a **ordem natural (alfab√©tica ou crescente)**.

## Quando usar `Set`

Use `Set` quando:

- Precisa **garantir que n√£o existam duplicatas**;
- N√£o precisa acessar elementos por √≠ndice;
- Quer manter **ordem (TreeSet)** ou **ordem de inser√ß√£o (LinkedHashSet)**;
- Deseja **verifica√ß√µes r√°pidas de exist√™ncia** (`contains()`).

---
# Interface `Map`

`Map<K, V>` √© uma estrutura que **mapeia chaves (`K`) a valores (`V`)**.  
Cada chave √© **√∫nica**, mas pode estar associada a **qualquer valor**.

**Pacote:** `java.util.Map`  
**Superinterface:** nenhuma de `Collection` ‚Äî `Map` √© independente.

## Principais Implementa√ß√µes

|Implementa√ß√£o|Caracter√≠sticas|
|---|---|
|`HashMap`|Baseado em hash. R√°pido, sem ordem.|
|`LinkedHashMap`|Mant√©m a ordem de inser√ß√£o.|
|`TreeMap`|Ordena as chaves de forma natural ou por `Comparator`.|
|`Hashtable`|Vers√£o antiga e sincronizada (evite usar).|

## Sintaxe B√°sica

```java
Map<String, Integer> idades = new HashMap<>();

idades.put("Ana", 25);
idades.put("Jo√£o", 30);
idades.put("Maria", 22);

System.out.println(idades.get("Jo√£o")); // 30
```

## M√©todos Comuns

|M√©todo|Descri√ß√£o|
|---|---|
|`put(K chave, V valor)`|Adiciona ou substitui valor associado √† chave.|
|`get(Object chave)`|Retorna o valor da chave.|
|`containsKey(Object chave)`|Verifica se a chave existe.|
|`containsValue(Object valor)`|Verifica se o valor existe.|
|`remove(Object chave)`|Remove o par pela chave.|
|`keySet()`|Retorna todas as chaves.|
|`values()`|Retorna todos os valores.|
|`entrySet()`|Retorna pares chave-valor.|

## Exemplo Explicado: `HashMap`

```java
import java.util.HashMap;
import java.util.Map;

public class ExemploMap {
    public static void main(String[] args) {
        Map<String, Double> notas = new HashMap<>();

        notas.put("Ana", 8.5);
        notas.put("Bruno", 7.0);
        notas.put("Carlos", 9.0);
        notas.put("Ana", 9.5); // substitui valor anterior

        System.out.println(notas.get("Ana")); // 9.5
        System.out.println("Chaves: " + notas.keySet());
        System.out.println("Valores: " + notas.values());
    }
}
```

**Sa√≠da:**

```
9.5
Chaves: [Bruno, Ana, Carlos]
Valores: [7.0, 9.5, 9.0]
```

**O que acontece:**

- Cada **chave** √© √∫nica ‚Äî ao inserir "Ana" novamente, o valor anterior √© **substitu√≠do**.
- O m√©todo `keySet()` retorna todas as chaves, e `values()` retorna todos os valores.

## Exemplo Explicado: Iterando com `entrySet()`

```java
for (Map.Entry<String, Double> entrada : notas.entrySet()) {
    System.out.println(entrada.getKey() + " -> " + entrada.getValue());
}
```

**Sa√≠da:**

```
Bruno -> 7.0
Ana -> 9.5
Carlos -> 9.0
```

**O que acontece:**

- Cada entrada (`Entry`) cont√©m **uma chave e seu valor associado**.  
- Esse loop √© muito usado para percorrer `Map`s de forma eficiente.

## Quando usar `Map`

Use `Map` quando:

- Precisa associar **valores a chaves √∫nicas**;
- Precisa de **acesso r√°pido** a dados via chave (ex: dicion√°rios, tabelas, caches);
- Precisa **armazenar pares chave-valor** de forma ordenada (`TreeMap`) ou na ordem de inser√ß√£o (`LinkedHashMap`).

---
# Comparativo R√°pido

|Interface|Permite Duplicatas?|Mant√©m Ordem?|Acesso por √çndice?|Armazena Chave-Valor?|
|---|---|---|---|---|
|**List**|‚úÖ Sim|‚úÖ Sim|‚úÖ Sim|‚ùå N√£o|
|**Set**|‚ùå N√£o|‚öôÔ∏è Depende da implementa√ß√£o|‚ùå N√£o|‚ùå N√£o|
|**Map**|üîë Chaves: ‚ùå / Valores: ‚úÖ|‚öôÔ∏è Depende da implementa√ß√£o|‚ùå N√£o|‚úÖ Sim|

---
# Conclus√£o

As interfaces **`List`**, **`Set`** e **`Map`** s√£o a base do **Java Collections Framework**, e dominar suas diferen√ßas √© essencial para criar **aplica√ß√µes eficientes e organizadas**.

- Use **`List`** quando precisar **manter a ordem** e **aceitar duplicatas**.    
- Use **`Set`** quando quiser **unicidade de elementos**.
- Use **`Map`** quando precisar **associar chaves a valores**.    

Cada implementa√ß√£o possui **caracter√≠sticas espec√≠ficas de desempenho e comportamento**, permitindo que o desenvolvedor escolha a estrutura **ideal para cada cen√°rio**.