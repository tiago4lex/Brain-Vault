2025-12-17 22:35

Status: #developed #python 

Tags: [[Python]] | [[Strings e Manipulação de Texto]] | [[Regex]]

----
# Introdução

**Expressões regulares** (*Regular Expressions* ou **Regex**) são padrões usados para **buscar, validar, extrair e substituir textos**. Em Python, elas são implementadas pelo módulo padrão `re`.

Regex é muito usado em:
- Validação de dados (e-mail, senha, CPF, IP, URL).
- Análise de logs.
- Segurança e detecção de padrões suspeitos.
- Web scraping.
- Processamento de grandes volumes de texto.

---
# Importando o módulo `re`

```python
import re
```

---
# Conceitos Básicos de Regex

## O que é um padrão?

Um **padrão** é uma sequência de caracteres que descreve o que você quer encontrar.

**Exemplo:**

- `abc` → procura exatamente "abc"
- `\d` → procura um dígito
- `[a-z]` → procura letras minúsculas

---
# Funções Principais do Módulo `re`

## 1. `re.search()`

Procura o padrão **em qualquer parte da string.**

```python
texto = "Meu email é teste@email.com"
resultado = re.search(r"email", texto)

if resultado:
	print("Padrão encontrado")
```

## 2. `re.match`

Verifica se o padrão ocorre **no início da string**.

```python
texto = "Python é incrível"
print(re.match(r"Python", texto))
```

## 3. `re.findall()`

Retorna **todas as ocorrências** encontradas.

```python
texto = "O número é 123 e outro é 456"
print(re.findall(r"\d+", texto))
```

**Resultado:**

```js
['123', '456']
```

## 4. `re.sub()`

Substitui padrões encontrados.

```python
texto = "Senha: 12345"
novo_texto = re.sub(r"\d", "*", texto)
print(novo_texto)
```

**Resultado:**

```text
Senha *****
```

---
# Metacaracteres Importantes

| **Símbolo** | **Significado**             |
| ----------- | --------------------------- |
| `.`         | Qualquer caractere          |
| `^`         | Início da String            |
| `$`         | Final da String             |
| `*`         | Zero ou mais ocorrências    |
| `+`         | Uma ou mais ocorrências     |
| `?`         | Zero ou mais uma ocorrência |

---
# Classes de Caracteres

## Classes Predefinidas

| **Classe** | **Significado**    |
| ---------- | ------------------ |
| `\d`       | Dígito (0-9)       |
| `\D`       | Não dígito         |
| `\w`       | Letra, número ou _ |
| `\W`       | Não letra/número   |
| `\s`       | Espaço em branco   |
| `\S`       | Não espaço         |

## Classes Personalizadas

```python
texto = "abc123"
print(re.findall(r"[a-z]", texto))
```

**Resultado:**

```js
['a', 'b', 'c']
```

---
# Quantificadores

| **Quantificador** | **Descrição**      |
| ----------------- | ------------------ |
| `{n}`             | Exatamente n vezes |
| `{n,}`            | Pelo menos n vezes |
| `{n,m}`           | Entre n e m vezes  |

**Exemplo:**

```python
texto = "AA BBB CCCC"
print(re.findall(r"A{2}|B{3}|C{4}", texto))
```

**Resultado:**

```js
['AA', 'BBB', 'CCCC']
```

---
# Grupos e Parênteses

Parênteses permitem **agrupar padrões** e extrair partes específicas.

```python
texto = "Telefone: (11) 99999-8888"
resultado = re.search(r"\((\d{2})\) (\d{5}-\d{4})", texto)

print(resultado.group(1)) # DDD
print(resultado.group(2)) # Número
```

**Resultado:**

```text
11
99999-8888
```

---
# Âncoras

- `^` → início da string
- `$` → final da string

```python
email = "teste@email.com"
print(re.match(r"^\w+@\w+\.\w+$", email))
```

```resultado
<re.Match object; span=(0, 15), match='teste@email.com'>
```

---
# Flags (Modificadores)

| **Flags**       | **Descrição**                |
| --------------- | ---------------------------- |
| `re.IGNORECASE` | Ignora maiúsculas/minúsculas |
| `re.MULTILINE`  | Múltiplas linhas             |
| `re.DOTALL`     | `.` inclui quebra de linha   |

**Exemplo:**

```python
re.search(r"python", "PYTHON", re.IGNORECASE)
```

---
# Regex para Validação (Exemplos Práticos)

## 1. Validar E-mail

```python
padrao = r"^[\w\.-]+@[\w\.-]+\.\w+$"
email = "teste@email.com"

print(bool(re.match(padrao, email)))
```

## 2. Validar Endereço IP

```python
ip = 192.168.0.1
padrao = r"^(\d{1,3}\.){3}\d{1,3}$"
print(bool(re.match(padrao, ip)))
```

---
# Exemplos Práticos

## Exemplo 1

João é atendente em uma farmácia e precisa verificar se um cliente forneceu um número de receita válido em uma descrição. O número da receita é sempre o único número presente no texto fornecido pelo cliente. Ele quer um programa que extraia esse número diretamente e confirme se o texto está correto, sem a necessidade de trabalhar com listas ou loops.

**Solução:**

```Python
import re

texto = input("Digite a descrição da receita: ")  
numero = re.findall(r'\d+', texto)[0]  
print(f"O número da receita é: {numero}")
```

## Exemplo 2

Nathalia é uma escritora que está revisando um texto para publicação. Durante o processo, ela percebeu que usou a palavra "bom" repetidamente, quando queria expressar algo mais forte, como "ótimo". Para economizar tempo, Nathalia quer substituir automaticamente todas as ocorrências da palavra "bom" por "ótimo" no texto.

**Solução:**

```Python
import re

texto = input("Digite o texto a ser revisado: ")  
palavra_antiga = input("Qual palavra deseja substituir? ")  
palavra_nova = input("Qual a nova palavra? ")  

nova_frase = re.sub(rf'\b{palavra_antiga}\b', palavra_nova, texto)
print(nova_frase)
```

## Exemplo 3

Lorena trabalha no setor de cadastros de uma empresa e precisa garantir que os nomes inseridos pelos clientes estejam no formato correto. O padrão esperado é que os nomes comecem com uma letra maiúscula e contenham apenas letras (sem números ou caracteres especiais). Para facilitar o trabalho, ela quer um programa que valide automaticamente os nomes fornecidos.

**Solução:**

```Python
import re

nome = input("Digite o nome do cliente para validação: ")  
if re.fullmatch(r'[A-Z][a-z]*', nome):
    print("Nome válido!")
else:
    print("Nome inválido!")
```

## Exemplo 4

Sara trabalha no setor de atendimento de uma empresa e precisa verificar rapidamente se os clientes estão digitando seus números de CPF no formato correto antes de registrar os dados no sistema.

O formato esperado do CPF é: três blocos de 3 dígitos separados por pontos (.), seguidos por um bloco de 2 dígitos separados por um traço (-).

**Solução:**

```Python
import re

cpf = input("Digite o CPF no formato XXX.XXX.XXX-XX: ")  
padrao = r'\d{3}\.\d{3}\.\d{3}-\d{2}'

if re.search(padrao, cpf):
    print("O CPF está no formato correto.")
else:
    print("O CPF está no formato incorreto.")
```

## Exemplo 5

Você trabalha em uma biblioteca e está organizando os títulos de livros no sistema. Você precisa identificar todos os títulos que possuem palavras iniciadas por uma determinada letra, para criar coleções temáticas baseadas em letras específicas. Por exemplo, você poderia usar isso para agrupar livros com palavras que começam com a mesma letra, ajudando na organização ou em campanhas como “Livros com A para você!”.

**Solução:**

```Python
import re

texto = input("Digite o título dos livro: ") 
letra = input("Digite a letra inicial para pesquisa: ")  
palavras = re.findall(rf'\b{letra}[a-zà-ÿ]*', texto, re.IGNORECASE)
print(palavras)
```

## Exemplo 6

Carlos é analista de dados em um hospital e está organizando informações de pacientes em um banco de dados. Ele recebe os dados no formato: "PrimeiroNome Sobrenome - Ano". Por exemplo, “Monalisa Silva - 1994”.

Carlos precisa de um programa que leia as informações, capture cada parte separadamente, nome, o sobrenome e o ano de nascimento para preencher os campos do sistema.

**Solução:**

```Python
import re

dados = input("Digite o nome completo e o ano de nascimento do paciente: ")  
padrao = r'(\w+) (\w+) - (\d{4})'  

resultado = re.search(padrao, dados)

if resultado:
    primeiro_nome = resultado.group(1)
    sobrenome = resultado.group(2)
    ano_nascimento = resultado.group(3)

    print(f"Primeiro Nome: {primeiro_nome}")
    print(f"Sobrenome: {sobrenome}")
    print(f"Ano de Nascimento: {ano_nascimento}")
else:
    print("Formato inválido!")
```

---
# Boas Práticas com Regex

- Use strings raw (`r""`) para evitar erros
- Teste padrões em pequenas strings
- Evite regex muito complexas
- Comente padrões difíceis

---
# Erros Comuns

❌ Esquecer de usar string raw
❌ Confundir `match()` com `search()`
❌ Criar regex muito permissiva

---
# Conclusão

Expressões regulares são uma ferramenta extremamente poderosa em Python. Embora pareçam complexas no início, com prática elas se tornam indispensáveis para validação, segurança, análise de logs e automação.

Dominar `re` é um grande diferencial para qualquer desenvolvedor Python, especialmente em áreas como **cibersegurança** e **engenharia de software**.