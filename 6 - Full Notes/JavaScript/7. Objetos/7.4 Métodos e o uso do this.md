2025-10-28 09:04

Status: #developed #javascript 

Tags: [[JavaScript]]

----
# O que são métodos em objetos

Em JavaScript, **métodos são funções armazenadas dentro de objetos**.
Eles são usados para definir **comportamentos**, ou seja, ações que o objeto pode executar.

No contexto de um objeto em Node.js, `this` refere-se ao próprio objeto no qual a função está sendo chamada. Ela é uma referência dinâmica, o que significa que o valor de `this` pode mudar dependendo do contexto em que a função é chamada.

## Sintaxe básica

```js
const pesso = {
	nome: "Maria",
	falar: function() {
		console.log("Olá! Meu nome é " + this.nome);
	}
}
```

**Neste exemplo:**

- `falar` é um **método** do objeto `pessoa`.
- Dentro dele, usamos o `this` para acessar a propriedade `nome` do mesmo objeto.

---
# O que é o `this`

O `this` é uma **palavra-chave especial** em JavaScript que **referencia o contexto atual de execução**, isto é, quem está chamando a função.

> Em outras palavras: o `this` é o **objeto dono da função sendo executada**.

---
# Como o `this` se comporta

O valor de `this`  muda dependendo de onde e como uma função é chamada.

## 1. Dentro de um método de objeto

Quando `this` é usado dentro de um **método**, ele se refere ao próprio objeto que chamou o método.

```js
const carro = {
	marca: "Toyota",
	modelo: "Corolla",
	exibirInfo: function() {
		console.log(`Carro: ${this.marca} ${this.modelo}`);
	}
};

carro.exibirInfo();
```

**Saída:**

```
Carro: Toyota Corolla
```

## 2. Fora de qualquer objeto (no escopo global)

No **modo não restrito *(non-strict)***, `this` se refere ao **objeto global**:

- No navegador: `window`
- No Node.js: `global`

```js
console.log(this === window); // true (em navegador)
```

No **modo estrito (`use strict`)**, o `this` é `undefined` fora de um objeto:

```js
"use strict";
console.log(this); // undefined
```

## 3. Em funções simples

Quando uma função comum é chamada diretamente (não com método), o `this` também se refere ao objeto global - exceto em modo restrito.

```js
function mostrar() {
	console.log(this);
}

mostrar(); // window (no navegador) ou undefined (em modo restrito)
```

## 4. Funções atribuídas a variáveis ou passadas como callback

Se a função for extraída de dentro de um objeto, o `this` perde o contexto:

```js
const pessoa = {
	nome: "Maria",
	falar() {
		console.log(this.nome)
	}
};

cost falarAgora = pessoa.falar;
falarAgora(); // undefined (perdeu o contexto)
```

**Solução:** usar `bind()` para "fixar" o `this`:

```js
const falarCorreto = pessoa.falar.bind(pessoa);
falarCorreto(); // Maria
```

## 5. Em funções arrow (` => `)

As **funções arrow** têm comportamento especial:

- Elas **não criam seu próprio `this`**, herdando o `this` do **escopo em que foram criadas**.

```js
const usuario = {
	nome: "Maria",
	saudacao: () => {
		console.log(this.nome);
	}
};

usuario.saudacao(); // undefined (não tem seu próprio this)
```

Para que funcione corretamente é necessário usar uma função normal:

```js
const usuarioCorreto = {
	nome: "Maria",
	saudacao() {
		console.log(this.nome);
	}
};

usuarioCorreto.saudacao(); // Maria
```

---
# Métodos úteis relacionados ao `this`

## `call()`

Permite chamar uma função e definir manualmente o `this`.

```js
function saudacao() {
	console.log(`Olá, ${this.nome}`);
}

const pessoa = { nome: "Maria" };

saudacao.call(pessoa); // Olá, Maria
```

## `apply()`

Semelhante ao `call()`, mas **recebe os argumentos como array**.

```js
function apresentar(cidade, idade) {
	console.log(`${this.nome} tem ${idade} anos e mora em ${cidade}.`);
}

const usuario = { nome: "Maria" };

appresentar.apply(usuario, ["São Paulo", 23]);
```

**Saída:**

```
Maria tem 23 anos e mora em São Paulo.
```

## `bind()`

Cria uma **nova função** com o `this` **permanentemente** associado ao objeto especificado.

```js
function mostrar() {
	console.log(this.nome);
}

const dev = { nome: "Maria"};

const mostrarDev = mostrar.bind(dev);
mostrarDev(); // Maria
```

---
# Resumo

| Contexto                        | Valor de `this`                                |
| ------------------------------- | ---------------------------------------------- |
| Método de um objeto             | O próprio objeto                               |
| Função simples                  | `window` (não estrito) / `undefined` (estrito) |
| Arrow function                  | Herdado do escopo externo                      |
| `call()` / `apply()` / `bind()` | Valor definido manualmente                     |
| Dentro de classes               | A instância da classe (`new`)                  |

---
# Exemplo com `this` em um Classe

```js
class Usuario {
	constructor(nome) {
		this.nome = nome;
	}
	
	apresentar() {
		console.log(`Olá! Meu nome é ${this.nome}.`);
	}
}

const dev = new Usuario("Maria");
dev.apresentar(); // Olá! Meu nome é Maria.
```

---
# Boas Práticas

- Evite usar `this` fora de objetos ou classes sem necessidade.    
- Prefira **arrow functions** em callbacks, quando você **não quer** um novo `this`.
- Use `bind()` para **manter o contexto correto** em eventos ou funções passadas como parâmetro.
- Sempre teste o valor de `this` se estiver incerto sobre o contexto.

---

# Conclusão

O `this` é uma das partes mais poderosas — e, ao mesmo tempo, mais complexas — do JavaScript.  
Ele permite que funções e métodos sejam **reutilizáveis e dinâmicos**, variando seu comportamento de acordo com o contexto de execução.

Dominar o `this` é um passo essencial para entender **POO (Programação Orientada a Objetos)** e **funções de alto nível** em JavaScript moderno.
